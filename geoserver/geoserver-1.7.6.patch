Index: release/installer/win-ng/GeoServerEXE.nsi
===================================================================
--- release/installer/win-ng/GeoServerEXE.nsi	(revision 14791)
+++ release/installer/win-ng/GeoServerEXE.nsi	(working copy)
@@ -54,13 +54,13 @@
 	Please report any problems or suggestions to the GeoServer Users mailing list: geoserver-users@lists.sourceforge.net. \r\n\r\n\
 	Click Next to continue."
 
-; What to do when done
-; !define MUI_FINISHPAGE_RUN "$INSTDIR\wrapper.exe -t ./bin/wrapper/wrapper.conf"
+; What to do when done
+; !define MUI_FINISHPAGE_RUN "$INSTDIR\wrapper.exe -t ./bin/wrapper/wrapper.conf"
 
 ; Install Page order
 ; This is the main list of installer things to do 
 !insertmacro MUI_PAGE_WELCOME                                 ; Hello
-Page custom CheckUserType                                     ; Die if not admin
+Page custom CheckUserType                                     ; Die if not admin
 !insertmacro MUI_PAGE_LICENSE "LICENSE.txt"                   ; Show license
 !insertmacro MUI_PAGE_DIRECTORY                               ; Where to install
 !insertmacro MUI_PAGE_STARTMENU Application $STARTMENU_FOLDER ; Start menu location
@@ -68,16 +68,16 @@
 Page custom DataDirCheck                                      ; Set data directory
 Page custom CredsCheck                                        ; Will set admin/password (if new install)
 Page custom Ready                                             ; Ready to install page
-!insertmacro MUI_PAGE_INSTFILES                               ; Actually do the install
-!insertmacro MUI_PAGE_FINISH                                  ; Done
+!insertmacro MUI_PAGE_INSTFILES                               ; Actually do the install
+!insertmacro MUI_PAGE_FINISH                                  ; Done
 
 ; Uninstall Page order
 !insertmacro MUI_UNPAGE_CONFIRM   ; Are you sure you wish to uninstall?
 !insertmacro MUI_UNPAGE_INSTFILES ; Do the uninstall
-!insertmacro MUI_UNPAGE_FINISH    ; Done
+!insertmacro MUI_UNPAGE_FINISH    ; Done
 
-; Set languages (first is default language)
-!insertmacro MUI_LANGUAGE "English"
+; Set languages (first is default language)
+!insertmacro MUI_LANGUAGE "English"
 !insertmacro MUI_RESERVEFILE_LANGDLL
 
 
@@ -93,7 +93,7 @@
          ;    has '0' if everything closed normally, and '-1' if some error occurred.
   Delete $TEMP\spltmp.bmp
 	
-; Extract install options from .ini files
+; Extract install options from .ini files
   !insertmacro MUI_INSTALLOPTIONS_EXTRACT "jdk.ini"
   !insertmacro MUI_INSTALLOPTIONS_EXTRACT "datadir.ini"
   !insertmacro MUI_INSTALLOPTIONS_EXTRACT "creds.ini"
@@ -102,115 +102,115 @@
 FunctionEnd
 
 
-; Check the user type, and quit if it's not an administrator.
-; Taken from Examples/UserInfo that ships with NSIS.
-Function CheckUserType
-  ClearErrors
-  UserInfo::GetName
-  IfErrors Win9x
-  Pop $0
-  UserInfo::GetAccountType
-  Pop $1
-  StrCmp $1 "Admin" Admin NoAdmin
-
-  NoAdmin:
-    MessageBox MB_ICONSTOP "Sorry, you must have administrative rights in order to install GeoServer"
+; Check the user type, and quit if it's not an administrator.
+; Taken from Examples/UserInfo that ships with NSIS.
+Function CheckUserType
+  ClearErrors
+  UserInfo::GetName
+  IfErrors Win9x
+  Pop $0
+  UserInfo::GetAccountType
+  Pop $1
+  StrCmp $1 "Admin" Admin NoAdmin
+
+  NoAdmin:
+    MessageBox MB_ICONSTOP "Sorry, you must have administrative rights in order to install GeoServer"
     Quit
-
-  Win9x:
-    MessageBox MB_ICONSTOP "This installer is not supported on Windows 9x/ME."
+
+  Win9x:
+    MessageBox MB_ICONSTOP "This installer is not supported on Windows 9x/ME."
     Quit
-		
+		
   Admin:
-	
+	
 FunctionEnd
 
 
-; Find the %JAVA_HOME% used on the system, and put the result on the top of the stack
-; Will return an empty string if the path cannot be determined
-Function findJavaPath
-
-  ClearErrors
-
-  ReadEnvStr $1 JAVA_HOME
-
-  IfErrors 0 FoundJDK
-
+; Find the %JAVA_HOME% used on the system, and put the result on the top of the stack
+; Will return an empty string if the path cannot be determined
+Function findJavaPath
+
   ClearErrors
-  ; Commented out becasue it appears to not distinguish between JDKs and JREs.
-  ; ReadRegStr $2 HKLM "SOFTWARE\JavaSoft\Java Runtime Environment" "CurrentVersion"
-  ; ReadRegStr $1 HKLM "SOFTWARE\JavaSoft\Java Runtime Environment\$2" "JavaHome"
-  ; ReadRegStr $3 HKLM "SOFTWARE\JavaSoft\Java Runtime Environment\$2" "RuntimeLib"
-
-  FoundJDK:
-  IfErrors 0 NoErrors
-  StrCpy $1 ""
-
-  NoErrors:
-  ClearErrors
-  ; Put the result in the stack
-  Push $1
-
+
+  ReadEnvStr $1 JAVA_HOME
+
+  IfErrors 0 FoundJDK
+
+  ClearErrors
+  ; Commented out becasue it appears to not distinguish between JDKs and JREs.
+  ; ReadRegStr $2 HKLM "SOFTWARE\JavaSoft\Java Runtime Environment" "CurrentVersion"
+  ; ReadRegStr $1 HKLM "SOFTWARE\JavaSoft\Java Runtime Environment\$2" "JavaHome"
+  ; ReadRegStr $3 HKLM "SOFTWARE\JavaSoft\Java Runtime Environment\$2" "RuntimeLib"
+
+  FoundJDK:
+  IfErrors 0 NoErrors
+  StrCpy $1 ""
+
+  NoErrors:
+  ClearErrors
+  ; Put the result in the stack
+  Push $1
+
 FunctionEnd
 
 ; The page to specify the %JAVA_HOME% path. 
-Function JavaCheck
-  !insertmacro MUI_HEADER_TEXT "$(TEXT_JDK_TITLE)" "$(TEXT_JDK_SUBTITLE)"
+Function JavaCheck
+  !insertmacro MUI_HEADER_TEXT "$(TEXT_JDK_TITLE)" "$(TEXT_JDK_SUBTITLE)"
   CheckAgain:
-	Call findJavaPath
+	Call findJavaPath
   Pop $3
-	; This puts the JDK, if any, into the field...
+	; This puts the JDK, if any, into the field...
   !insertmacro MUI_INSTALLOPTIONS_WRITE "jdk.ini" "Field 4" "State" $3
   !insertmacro MUI_INSTALLOPTIONS_DISPLAY "jdk.ini"
 	
-	; ...and reads it back in (may be redundant)
-  !insertmacro MUI_INSTALLOPTIONS_READ $3 "jdk.ini" "Field 4" "State"
+	; ...and reads it back in (may be redundant)
+  !insertmacro MUI_INSTALLOPTIONS_READ $3 "jdk.ini" "Field 4" "State"
   IfFileExists "$3\bin\java.exe" NoErrors Errors
 	
-	Errors:
+	Errors:
     MessageBox MB_RETRYCANCEL|MB_ICONSTOP "No Java Development Kit (JDK) found in folder:$\r$\n$3$\r$\nPress Retry to try again or Cancel to Exit." IDRETRY CheckAgain IDCANCEL Kill
 
   Kill:
     MessageBox MB_OK "Setup will now exit.  Please make sure you have a valid JDK on your system."
   Quit
-	
-  NoErrors:
-    StrCpy "$JavaHome" $3
-
+	
+  NoErrors:
+    StrCpy "$JavaHome" $3
+
 FunctionEnd
 
 
-; Find the %GEOSERVER_DATA_DIR% used on the system, and put the result on the top of the stack
+; Find the %GEOSERVER_DATA_DIR% used on the system, and put the result on the top of the stack
 ; Will return an empty string if the path cannot be determined
-Function findDataDirPath
-
-  ClearErrors
-  ReadEnvStr $1 GEOSERVER_DATA_DIR
-  IfErrors 0 NoErrors
-
-  StrCpy $1 "$INSTDIR\data_dir"
-
-  NoErrors:
-    ClearErrors
-    ; Put the result in the stack
-    Push $1
-
+Function findDataDirPath
+
+  ClearErrors
+  ReadEnvStr $1 GEOSERVER_DATA_DIR
+  IfErrors 0 NoErrors
+
+  StrCpy $1 "$INSTDIR\data_dir"
+
+  NoErrors:
+    ClearErrors
+    ; Put the result in the stack
+    Push $1
+
 FunctionEnd
 
 
 Function DataDirCheck
 	
 	!insertmacro MUI_HEADER_TEXT "$(TEXT_DATADIR_TITLE)" "$(TEXT_DATADIR_SUBTITLE)"
-	
+	
   CheckDirAgain:
-	Call findDataDirPath
+	Call findDataDirPath
   Pop $4
-	; This puts the JDK, if any, into the field.
+	; This puts the JDK, if any, into the field.
   !insertmacro MUI_INSTALLOPTIONS_WRITE "datadir.ini" "Field 2" "State" $4
   !insertmacro MUI_INSTALLOPTIONS_DISPLAY "datadir.ini"
 	
-	;...and reads it back in (may be redundant)
-  !insertmacro MUI_INSTALLOPTIONS_READ $4 "datadir.ini" "Field 2" "State"
+	;...and reads it back in (may be redundant)
+  !insertmacro MUI_INSTALLOPTIONS_READ $4 "datadir.ini" "Field 2" "State"
   IfFileExists "$4\catalog.xml" Exist Errors
 		
   Errors:
@@ -235,7 +235,7 @@
 	  MessageBox MB_OK "Setup will use the existing data directory at:$\r$\n$4"
 		StrCpy $DataNewOrUsed "Used"
 	  Goto NoErrors
-	
+	
   NoErrors:
 	StrCpy "$DataDir" $4
 	
@@ -281,18 +281,18 @@
 
 FunctionEnd
 
-
+
 ; The main install section
 Section "GeoServer" Main_Sec
 	
 	; Makes this install mandatory, although not necessary as it's the only section
 	SectionIn RO
-
-	; Set Section properties
-	SetOverwrite on
-
-	; Set Section Files and Shortcuts
-	SetOutPath "$INSTDIR\"
+
+	; Set Section properties
+	SetOverwrite on
+
+	; Set Section Files and Shortcuts
+	SetOutPath "$INSTDIR\"
 	File /a start.jar
 	File /a GPL.txt
 	File /a LICENSE.txt
@@ -313,9 +313,9 @@
 	
 	; New users.properties file is created here
 	WriteCreds:
-		Delete "$DataDir\security\users.properties"
+		Delete "$DataDir\security\users.properties"
     FileOpen $R9 "$DataDir\security\users.properties" w
-	  FileWrite $R9 "$6=$7,ROLE_ADMINISTRATOR"
+	  FileWrite $R9 "$6=$7,ROLE_SV_ADMIN"
     FileClose $R9
 	
 	NoWriteCreds:
@@ -338,25 +338,25 @@
     CreateShortCut "$SMPROGRAMS\$STARTMENU_FOLDER\Uninstall.lnk" "$INSTDIR\Uninstall.exe"
 	
   !insertmacro MUI_STARTMENU_WRITE_END
-	
-SectionEnd
+	
+SectionEnd
 
 
-; What happens at the end of the install.
+; What happens at the end of the install.
 Section -FinishSection
-
-	WriteRegStr HKLM "Software\${APPNAME}" "" "$INSTDIR"
-	WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\${APPNAMEANDVERSION}" "DisplayName" "${APPNAMEANDVERSION}"
-	WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\${APPNAMEANDVERSION}" "UninstallString" "$INSTDIR\uninstall.exe"
-	WriteUninstaller "$INSTDIR\uninstall.exe"
-
-SectionEnd
 
+	WriteRegStr HKLM "Software\${APPNAME}" "" "$INSTDIR"
+	WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\${APPNAMEANDVERSION}" "DisplayName" "${APPNAMEANDVERSION}"
+	WriteRegStr HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\${APPNAMEANDVERSION}" "UninstallString" "$INSTDIR\uninstall.exe"
+	WriteUninstaller "$INSTDIR\uninstall.exe"
+
+SectionEnd
+
 ; Commented out as there's only one install component
-; Modern install component descriptions
-; !insertmacro MUI_FUNCTION_DESCRIPTION_BEGIN
-;	  !insertmacro MUI_DESCRIPTION_TEXT ${Main_Sec} "Installs Geoserver core components."
-; !insertmacro MUI_FUNCTION_DESCRIPTION_END
+; Modern install component descriptions
+; !insertmacro MUI_FUNCTION_DESCRIPTION_BEGIN
+;	  !insertmacro MUI_DESCRIPTION_TEXT ${Main_Sec} "Installs Geoserver core components."
+; !insertmacro MUI_FUNCTION_DESCRIPTION_END
 
 
 ; ----------------------------------
@@ -516,32 +516,32 @@
 ; ----------------------------------
 
 
-;Uninstall section
-Section Uninstall
+;Uninstall section
+Section Uninstall
 
   Push GEOSERVER_DATA_DIR
   Call un.DeleteEnvStr
-
-	;Remove from registry...
-	DeleteRegKey HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\${APPNAMEANDVERSION}"
-	DeleteRegKey HKLM "SOFTWARE\${APPNAME}"
-
-	; Delete self
+
+	;Remove from registry...
+	DeleteRegKey HKLM "Software\Microsoft\Windows\CurrentVersion\Uninstall\${APPNAMEANDVERSION}"
+	DeleteRegKey HKLM "SOFTWARE\${APPNAME}"
+
+	; Delete self
 	Delete "$INSTDIR\uninstall.exe"
 	
 	; Remove service
-  nsExec::Exec "$INSTDIR\wrapper.exe -r ./bin/wrapper/wrapper.conf"
+  nsExec::Exec "$INSTDIR\wrapper.exe -r ./bin/wrapper/wrapper.conf"
 
-
-	; Delete Shortcuts
-	RMDir /r "$SMPROGRAMS\${APPNAMEANDVERSION}"
-
-	; Clean up GeoServer
-	RMDir /r "$INSTDIR\"
-
-SectionEnd
 
-; This is the gray text on the bottom left of the installer.
-; BrandingText "Where does this text go"
-
+	; Delete Shortcuts
+	RMDir /r "$SMPROGRAMS\${APPNAMEANDVERSION}"
+
+	; Clean up GeoServer
+	RMDir /r "$INSTDIR\"
+
+SectionEnd
+
+; This is the gray text on the bottom left of the installer.
+; BrandingText "Where does this text go"
+
 ; eof
\ No newline at end of file
Index: main/src/main/java/applicationSecurityContext.xml
===================================================================
--- main/src/main/java/applicationSecurityContext.xml	(revision 14791)
+++ main/src/main/java/applicationSecurityContext.xml	(working copy)
@@ -76,7 +76,7 @@
       <constructor-arg type="java.lang.String">
           <value>
                /**:GET=IS_AUTHENTICATED_ANONYMOUSLY
-               /**:POST,DELETE,PUT=ROLE_AUTHENTICATED,ROLE_ADMINISTRATOR
+               /**:POST,DELETE,PUT=ROLE_AUTHENTICATED,ROLE_SV_ADMIN
           </value>
       </constructor-arg>
   </bean>
@@ -107,7 +107,7 @@
       <value>
         CONVERT_URL_TO_LOWERCASE_BEFORE_COMPARISON
         PATTERN_TYPE_APACHE_ANT 
-        /config/**=ROLE_ADMINISTRATOR
+        /config/**=ROLE_SV_ADMIN
         /**=IS_AUTHENTICATED_ANONYMOUSLY
       </value>
     </property>
Index: main/src/main/java/org/geoserver/security/SecureCatalogImpl.java
===================================================================
--- main/src/main/java/org/geoserver/security/SecureCatalogImpl.java	(revision 14791)
+++ main/src/main/java/org/geoserver/security/SecureCatalogImpl.java	(working copy)
@@ -35,6 +35,8 @@
 import org.geoserver.platform.GeoServerExtensions;
 import org.geoserver.platform.GeoServerResourceLoader;
 import org.geoserver.security.DataAccessManager.CatalogMode;
+import org.geoserver.security.collection.SecureList;
+import org.geoserver.security.collection.SecurityAccessCheck;
 import org.geoserver.security.decorators.SecuredCoverageInfo;
 import org.geoserver.security.decorators.SecuredCoverageStoreInfo;
 import org.geoserver.security.decorators.SecuredDataStoreInfo;
@@ -621,15 +623,33 @@
      * 
      * @return
      */
-    protected <T extends ResourceInfo> List<T> filterResources(Authentication user,
+    protected <T extends ResourceInfo> List<T> filterResources(final Authentication user,
             List<T> resources) {
         List<T> result = new ArrayList<T>();
         for (T original : resources) {
-            T secured = checkAccess(user, original);
-            if (secured != null)
-                result.add(secured);
+            try {
+                T secured = checkAccess(user, original);
+                if (secured != null)
+                    result.add(secured);
+                
+            // even if there is a security exception we will add it to the 
+            // list because the secure list will check it again.
+            //
+            // This is to fix http://jira.codehaus.org/browse/GEOS-3803
+            // the idea is that the user can request the list of resources
+            // but no exception should be thrown until a request is made for the
+            // actual layer itself
+            } catch (InsufficientAuthenticationException iae){
+                result.add(original);
+            } catch (AccessDeniedException ade) {
+                result.add(original);
+            }
         }
-        return result;
+        return new SecureList<T>(result, new SecurityAccessCheck<T>() {
+            public T checkAccess(T item) { 
+                return SecureCatalogImpl.this.checkAccess(user, item);
+            }
+        });
     }
 
     /**
@@ -641,14 +661,31 @@
      * 
      * @return
      */
-    protected <T extends StoreInfo> List<T> filterStores(Authentication user, List<T> resources) {
+    protected <T extends StoreInfo> List<T> filterStores(final Authentication user, List<T> resources) {
         List<T> result = new ArrayList<T>();
         for (T original : resources) {
-            T secured = checkAccess(user, original);
-            if (secured != null)
-                result.add(secured);
+            try {
+                T secured = checkAccess(user, original);
+                if (secured != null)
+                    result.add(secured);
+            // even if there is a security exception we will add it to the 
+            // list because the secure list will check it again.
+            //
+            // This is to fix http://jira.codehaus.org/browse/GEOS-3803
+            // the idea is that the user can request the list of resources
+            // but no exception should be thrown until a request is made for the
+            // actual layer itself
+            } catch (InsufficientAuthenticationException iae){
+                result.add(original);
+            } catch (AccessDeniedException ade) {
+                result.add(original);
+            }
         }
-        return result;
+        return new SecureList<T>(result, new SecurityAccessCheck<T>() {
+            public T checkAccess(T item) { 
+                return SecureCatalogImpl.this.checkAccess(user, item);
+            }
+        });
     }
 
     /**
@@ -660,14 +697,31 @@
      * 
      * @return
      */
-    protected List<LayerGroupInfo> filterGroups(Authentication user, List<LayerGroupInfo> groups) {
+    protected List<LayerGroupInfo> filterGroups(final Authentication user, List<LayerGroupInfo> groups) {
         List<LayerGroupInfo> result = new ArrayList<LayerGroupInfo>();
         for (LayerGroupInfo original : groups) {
-            LayerGroupInfo secured = checkAccess(user, original);
-            if (secured != null)
-                result.add(secured);
+            try{
+                LayerGroupInfo secured = checkAccess(user, original);
+                if (secured != null)
+                    result.add(secured);
+            // even if there is a security exception we will add it to the 
+            // list because the secure list will check it again.
+            //
+            // This is to fix http://jira.codehaus.org/browse/GEOS-3803
+            // the idea is that the user can request the list of resources
+            // but no exception should be thrown until a request is made for the
+            // actual layer itself
+            } catch (InsufficientAuthenticationException iae){
+                result.add(original);
+            } catch (AccessDeniedException ade) {
+                result.add(original);
+            }
         }
-        return result;
+        return new SecureList<LayerGroupInfo>(result, new SecurityAccessCheck<LayerGroupInfo>() {
+            public LayerGroupInfo checkAccess(LayerGroupInfo item) { 
+                return SecureCatalogImpl.this.checkAccess(user, item);
+            }
+        });
     }
 
     /**
@@ -679,14 +733,31 @@
      * 
      * @return
      */
-    protected List<LayerInfo> filterLayers(Authentication user, List<LayerInfo> layers) {
+    protected List<LayerInfo> filterLayers(final Authentication user, List<LayerInfo> layers) {
         List<LayerInfo> result = new ArrayList<LayerInfo>();
         for (LayerInfo original : layers) {
-            LayerInfo secured = checkAccess(user, original);
-            if (secured != null)
-                result.add(secured);
+            try {
+                LayerInfo secured = checkAccess(user, original);
+                if (secured != null)
+                    result.add(secured);
+            // even if there is a security exception we will add it to the 
+            // list because the secure list will check it again.
+            //
+            // This is to fix http://jira.codehaus.org/browse/GEOS-3803
+            // the idea is that the user can request the list of resources
+            // but no exception should be thrown until a request is made for the
+            // actual layer itself
+            } catch (InsufficientAuthenticationException iae){
+                result.add(original);
+            } catch (AccessDeniedException ade) {
+                result.add(original);
+            }
         }
-        return result;
+        return new SecureList<LayerInfo>(result, new SecurityAccessCheck<LayerInfo>() {
+            public LayerInfo checkAccess(LayerInfo item) { 
+                return SecureCatalogImpl.this.checkAccess(user, item);
+            }
+        });
     }
 
     /**
@@ -698,15 +769,33 @@
      * 
      * @return
      */
-    protected <T extends NamespaceInfo> List<T> filterNamespaces(Authentication user,
+    protected <T extends NamespaceInfo> List<T> filterNamespaces(final Authentication user,
             List<T> namespaces) {
         List<T> result = new ArrayList<T>();
         for (T original : namespaces) {
-            T secured = checkAccess(user, original);
-            if (secured != null)
-                result.add(secured);
+            try {
+                T secured = checkAccess(user, original);
+                if (secured != null)
+                    result.add(secured);
+            // even if there is a security exception we will add it to the 
+            // list because the secure list will check it again.
+            //
+            // This is to fix http://jira.codehaus.org/browse/GEOS-3803
+            // the idea is that the user can request the list of resources
+            // but no exception should be thrown until a request is made for the
+            // actual layer itself
+            } catch (InsufficientAuthenticationException iae){
+                result.add(original);
+            } catch (AccessDeniedException ade) {
+                result.add(original);
+            }
+
         }
-        return result;
+        return new SecureList<T>(result, new SecurityAccessCheck<T>() {
+            public T checkAccess(T item) { 
+                return SecureCatalogImpl.this.checkAccess(user, item);
+            }
+        });
     }
 
     /**
@@ -718,15 +807,33 @@
      * 
      * @return
      */
-    protected <T extends WorkspaceInfo> List<T> filterWorkspaces(Authentication user,
+    protected <T extends WorkspaceInfo> List<T> filterWorkspaces(final Authentication user,
             List<T> workspaces) {
         List<T> result = new ArrayList<T>();
         for (T original : workspaces) {
-            T secured = checkAccess(user, original);
-            if (secured != null)
-                result.add(secured);
+            try {
+                T secured = checkAccess(user, original);
+                if (secured != null)
+                    result.add(secured);
+            // even if there is a security exception we will add it to the 
+            // list because the secure list will check it again.
+            //
+            // This is to fix http://jira.codehaus.org/browse/GEOS-3803
+            // the idea is that the user can request the list of resources
+            // but no exception should be thrown until a request is made for the
+            // actual layer itself
+            } catch (InsufficientAuthenticationException iae){
+                result.add(original);
+            } catch (AccessDeniedException ade) {
+                result.add(original);
+            }
+
         }
-        return result;
+        return new SecureList<T>(result, new SecurityAccessCheck<T>() {
+            public T checkAccess(T item) { 
+                return SecureCatalogImpl.this.checkAccess(user, item);
+            }
+        });
     }
     
     // -------------------------------------------------------------------
Index: main/src/main/java/org/geoserver/security/SecureTreeNode.java
===================================================================
--- main/src/main/java/org/geoserver/security/SecureTreeNode.java	(revision 14791)
+++ main/src/main/java/org/geoserver/security/SecureTreeNode.java	(working copy)
@@ -29,7 +29,7 @@
     /**
      * The role given to the administrators
      */
-    static final String ROOT_ROLE = "ROLE_ADMINISTRATOR";
+    static final String ROOT_ROLE = "ROLE_SV_ADMIN";
 
     Map<String, SecureTreeNode> children = new HashMap<String, SecureTreeNode>();
 
Index: main/src/main/java/org/geoserver/security/GeoserverUserDao.java
===================================================================
--- main/src/main/java/org/geoserver/security/GeoserverUserDao.java	(revision 14791)
+++ main/src/main/java/org/geoserver/security/GeoserverUserDao.java	(working copy)
@@ -68,9 +68,9 @@
                         if ((geoServer != null) && (geoServer.getAdminUserName() != null)
                                 && !geoServer.getAdminUserName().trim().equals("")) {
                             p.put(geoServer.getAdminUserName(),
-                                geoServer.getAdminPassword() + ",ROLE_ADMINISTRATOR");
+                                geoServer.getAdminPassword() + ",ROLE_SV_ADMIN");
                         } else {
-                            p.put("admin", "geoserver,ROLE_ADMINISTRATOR");
+                            p.put("admin", "geoserver,ROLE_SV_ADMIN");
                         }
 
                         os = new FileOutputStream(propFile);
Index: main/src/main/java/org/geoserver/security/DefaultDataAccessManager.java
===================================================================
--- main/src/main/java/org/geoserver/security/DefaultDataAccessManager.java	(revision 14791)
+++ main/src/main/java/org/geoserver/security/DefaultDataAccessManager.java	(working copy)
@@ -66,7 +66,7 @@
     PropertyFileWatcher watcher;
 
     File layers;
-
+    
     /**
      * Default to the highest security mode
      */
@@ -107,6 +107,7 @@
                         this.root = buildAuthorizationTree(watcher.getProperties());
                     }
                 }
+                
             } else if(watcher != null && watcher.isStale()) { 
                 root = buildAuthorizationTree(watcher.getProperties());
             }
@@ -115,7 +116,7 @@
                     + ", keeping old rules", e);
         }
     }
-    
+
     public CatalogMode getMode() {
         return mode;
     }
Index: main/src/main/java/org/geoserver/security/EditableUserDAO.java
===================================================================
--- main/src/main/java/org/geoserver/security/EditableUserDAO.java	(revision 14791)
+++ main/src/main/java/org/geoserver/security/EditableUserDAO.java	(working copy)
@@ -112,7 +112,7 @@
 	  true,
 	  true,
 	  new GrantedAuthority[]{
-	  new GrantedAuthorityImpl("ROLE_ADMINISTRATOR")
+	  new GrantedAuthorityImpl("ROLE_SV_ADMIN")
 	  }
 	  ));
   }
Index: main/src/main/java/org/vfny/geoserver/global/Data.java
===================================================================
--- main/src/main/java/org/vfny/geoserver/global/Data.java	(revision 14791)
+++ main/src/main/java/org/vfny/geoserver/global/Data.java	(working copy)
@@ -16,11 +16,12 @@
 import java.util.Map;
 import java.util.NoSuchElementException;
 import java.util.Set;
-import java.util.Map.Entry;
 import java.util.logging.Level;
 
 import javax.xml.namespace.QName;
 
+import org.acegisecurity.AccessDeniedException;
+import org.acegisecurity.InsufficientAuthenticationException;
 import org.geoserver.catalog.Catalog;
 import org.geoserver.catalog.LayerInfo;
 import org.geoserver.catalog.NamespaceInfo;
@@ -28,6 +29,10 @@
 import org.geoserver.catalog.StyleInfo;
 import org.geoserver.catalog.WorkspaceInfo;
 import org.geoserver.catalog.event.CatalogListener;
+import org.geoserver.security.collection.MappingStrategy;
+import org.geoserver.security.collection.Entry;
+import org.geoserver.security.collection.KeyValueMappingStrategy;
+import org.geoserver.security.collection.SecureCollection;
 import org.geotools.data.DataStore;
 import org.geotools.data.DefaultTransaction;
 import org.geotools.data.FeatureSource;
@@ -298,21 +303,23 @@
     }
 
     public synchronized Set getDataStores() {
-        Set dataStores = new HashSet();
-        for ( org.geoserver.catalog.DataStoreInfo ds : catalog.getDataStores() ) {
-            dataStores.add( new DataStoreInfo( ds, catalog ) );
-        }
-        return dataStores;
-        //return new HashSet(dataStores.values());
+        return SecureCollection.toSet(catalog.getDataStores(),
+                new MappingStrategy<org.geoserver.catalog.DataStoreInfo, DataStoreInfo>() {
+            public DataStoreInfo map(org.geoserver.catalog.DataStoreInfo ds) {
+                return new DataStoreInfo(ds, catalog);
+            }
+        });
     }
 
     public synchronized Set getFormats() {
-        Set coverageStores = new HashSet();
-        for ( org.geoserver.catalog.CoverageStoreInfo cs : catalog.getCoverageStores() ) {
-            coverageStores.add( new CoverageStoreInfo( cs, catalog ) );
-        }
-        return coverageStores;
-        //return new HashSet(formats.values());
+        return SecureCollection.toSet(catalog.getCoverageStores(), 
+                new MappingStrategy<org.geoserver.catalog.CoverageStoreInfo, CoverageStoreInfo>() {
+
+                    public CoverageStoreInfo map(org.geoserver.catalog.CoverageStoreInfo cs) {
+                        return new CoverageStoreInfo( cs, catalog );
+                    }
+                }
+        );
     }
 
     private final Map loadFormats(DataDTO dto) {
@@ -1434,31 +1441,17 @@
      * @return Map of Exception by dataStoreId:typeName
      */
     public synchronized Map statusDataStores() {
-        Map m = new HashMap();
-//        if ( errors == null ) {
-            for (org.geoserver.catalog.FeatureTypeInfo ft : catalog.getFeatureTypes() ) {
+        KeyValueMappingStrategy<org.geoserver.catalog.FeatureTypeInfo, org.geoserver.catalog.FeatureTypeInfo, Object> nameToInfoMapping = new KeyValueMappingStrategy<org.geoserver.catalog.FeatureTypeInfo, org.geoserver.catalog.FeatureTypeInfo, Object>() {
+            public Entry<org.geoserver.catalog.FeatureTypeInfo, Object> map(org.geoserver.catalog.FeatureTypeInfo ft) {
                 org.geoserver.catalog.DataStoreInfo ds = ft.getStore();
                 if ( ds.getError() != null ) {
-                    m.put( ft, ds.getError() );
-                    continue;
+                    return Entry.entry(ft, (Object) ds.getError() );
+                } else {
+                    return Entry.entry(ft, (Object) ft.isEnabled() );
                 }
-                
-                m.put( ft, ft.isEnabled() );
             }
-            
-            return m;
-//        }
-//        else {
-//            Iterator i = errors.entrySet().iterator();
-//            
-//            while (i.hasNext()) {
-//                Map.Entry e = (Map.Entry) i.next();
-//                FeatureTypeInfoDTO ftdto = (FeatureTypeInfoDTO) e.getKey();
-//                m.put(ftdto.getDataStoreId() + ":" + ftdto.getName(), e.getValue());
-//            }
-//            
-//            return m;    
-//        }
+        };
+        return SecureCollection.toMap(catalog.getFeatureTypes(), nameToInfoMapping);
     }
 
     /**
@@ -1597,7 +1590,7 @@
 
         tmp = new HashMap();
         for ( Iterator e = getFeatureTypeInfos().entrySet().iterator(); e.hasNext(); ) {
-            Map.Entry entry = (Entry) e.next();
+            Map.Entry entry = (Map.Entry) e.next();
             try {
                 String key = (String) entry.getKey();
                 FeatureTypeInfo fti = (FeatureTypeInfo) entry.getValue();
@@ -1621,7 +1614,7 @@
  
         tmp = new HashMap();
         for ( Iterator e = getCoverageInfos().entrySet().iterator(); e.hasNext(); ) {
-            Map.Entry entry = (Entry) e.next();
+            Map.Entry entry = (Map.Entry) e.next();
             try {
                 String key = (String) entry.getKey();
                 CoverageInfo ci = (CoverageInfo) entry.getValue();
@@ -1699,16 +1692,17 @@
      * @return NameSpaceInfo[]
      */
     public synchronized NameSpaceInfo[] getNameSpaces() {
-        NameSpaceInfo[] ns = new NameSpaceInfo[catalog.getNamespaces().size()];
-        int i = 0;
-        for ( NamespaceInfo namespace : catalog.getNamespaces() ) {
-            ns[i++] = new NameSpaceInfo( namespace, catalog );
+        ArrayList<NameSpaceInfo> list = new ArrayList<NameSpaceInfo>();
+        for(Iterator<NamespaceInfo> iter = catalog.getNamespaces().iterator();
+            iter.hasNext(); ){
+            try {
+                list.add(new NameSpaceInfo(iter.next(), catalog ));
+            } catch (AccessDeniedException e) {
+                // don't add
+            }
         }
-        return ns;
         
-        //NameSpaceInfo[] ns = new NameSpaceInfo[nameSpaces.values().size()];
-        //
-        //return (NameSpaceInfo[]) new ArrayList(nameSpaces.values()).toArray(ns);
+        return list.toArray(new NameSpaceInfo[list.size()]);
     }
 
     /**
@@ -1787,17 +1781,18 @@
      * @uml.property name="styles"
      */
     public synchronized Map getStyles() {
-        HashMap styles = new HashMap();
-        for (StyleInfo s : catalog.getStyles() ) {
-            try {
-                styles.put( s.getName(),s.getStyle());
-            } 
-            catch (IOException e) {
-                throw new RuntimeException( e );
+        return SecureCollection.toMap(catalog.getStyles(),
+                new KeyValueMappingStrategy<StyleInfo, String, Style>() {
+            public Entry<String, Style> map(StyleInfo s) {
+                try {
+                    return Entry.entry(s.getName(), s.getStyle());
+                }
+                catch (IOException e) {
+                    throw new RuntimeException(e);
+                }
             }
         }
-        return styles;
-        //return this.styles;
+                );
     }
 
     public synchronized Style getStyle(String id) {
@@ -2085,13 +2080,21 @@
      * @return Map of FetureTypeInfo by prefix:typeName
      */
     public synchronized Map getFeatureTypeInfos() {
-        Map map = new HashMap();
-        for ( org.geoserver.catalog.FeatureTypeInfo ft : catalog.getFeatureTypes() ) {
-            //if(ft.isEnabled())
-                map.put( ft.getPrefixedName(), new FeatureTypeInfo( layer( ft ), catalog ) );
-        }
-        return map;
-        //return Collections.unmodifiableMap(featureTypes);
+        return SecureCollection.toMap(catalog.getFeatureTypes(),
+                new KeyValueMappingStrategy<org.geoserver.catalog.FeatureTypeInfo, String, FeatureTypeInfo>() {
+
+            public Entry<String, FeatureTypeInfo> map(org.geoserver.catalog.FeatureTypeInfo ft) {
+                String prefixedName = ft.getPrefixedName();
+                try {
+                    return Entry.entry(prefixedName, new FeatureTypeInfo(layer(ft), catalog));
+                } catch (InsufficientAuthenticationException iae){
+                    return Entry.entry(prefixedName, null);
+                } catch (AccessDeniedException ade) {
+                    return Entry.entry(prefixedName, null);
+                }
+            }
+
+        });
     }
 
     LayerInfo layer( ResourceInfo r ) {
@@ -2103,13 +2106,19 @@
     }
     
     public synchronized Map getCoverageInfos() {
-        Map map = new HashMap();
-        for ( org.geoserver.catalog.CoverageInfo c : catalog.getCoverages() ) {
-            //if(c.isEnabled())
-                map.put( c.getPrefixedName(), new CoverageInfo( layer(c), catalog ) );
-        }
-        return map;
-        //return Collections.unmodifiableMap(coverages);
+        KeyValueMappingStrategy<org.geoserver.catalog.CoverageInfo, String, CoverageInfo> nameToInfoMapping = new KeyValueMappingStrategy<org.geoserver.catalog.CoverageInfo, String, CoverageInfo>() {
+            public Entry<String, CoverageInfo> map(org.geoserver.catalog.CoverageInfo c) {
+                String prefixedName = c.getPrefixedName();
+                try {
+                    return Entry.entry(prefixedName, new CoverageInfo( layer(c), catalog ));
+                } catch (InsufficientAuthenticationException iae){
+                    return Entry.entry(prefixedName, null);
+                } catch (AccessDeniedException ade) {
+                    return Entry.entry(prefixedName, null);
+                }
+            }
+        };
+        return SecureCollection.toMap(catalog.getCoverages(), nameToInfoMapping);
     }
 
     // TODO: detect if a user put a full url, instead of just one to be
@@ -2552,12 +2561,13 @@
      * @see org.geotools.data.Catalog#getPrefixes()
      */
     public synchronized Set getPrefixes() {
-        Set prefixes = new HashSet();
-        for ( NamespaceInfo ns : catalog.getNamespaces() ) {
-            prefixes.add( ns.getPrefix() );
-        }
-        return prefixes;
-        //return Collections.unmodifiableSet(nameSpaces.keySet());
+        return SecureCollection.toSet(catalog.getNamespaces(),
+           new MappingStrategy<NamespaceInfo, String>() {
+                public String map(NamespaceInfo ns) {
+                    return ns.getPrefix();
+                }
+            }
+        );
     }
 
     /**
@@ -2738,12 +2748,13 @@
      * @return
      */
     public Set getLayerNames() {
-        HashSet layerNames = new HashSet();
-        for ( LayerInfo l : catalog.getLayers() ) {
-            layerNames.add( l.getName() );
-        }
-        return layerNames;
-        //return Collections.unmodifiableSet(layerNames.keySet());
+        return SecureCollection.toSet(catalog.getLayers(),
+            new MappingStrategy<LayerInfo, String>() {
+                public String map(LayerInfo from) {
+                    return from.getName();
+                }
+            }
+        );
     }
     
     public void destroy() throws Exception {
Index: wfs/src/main/java/org/geoserver/wfs/DescribeFeatureType.java
===================================================================
--- wfs/src/main/java/org/geoserver/wfs/DescribeFeatureType.java	(revision 14791)
+++ wfs/src/main/java/org/geoserver/wfs/DescribeFeatureType.java	(working copy)
@@ -13,6 +13,8 @@
 import java.util.Collection;
 import java.util.Iterator;
 import java.util.List;
+import java.util.Map;
+
 import javax.xml.namespace.QName;
 
 
@@ -66,7 +68,7 @@
     public void setCatalog(Data catalog) {
         this.catalog = catalog;
     }
-
+    @SuppressWarnings({ "deprecation", "unchecked" })
     public FeatureTypeInfo[] run(DescribeFeatureTypeType request)
         throws WFSException {
         List names = new ArrayList(request.getTypeName());
@@ -100,45 +102,32 @@
         }
 
         //list of catalog handles
-        Collection infos = catalog.getFeatureTypeInfos().values();
+        Map<String, FeatureTypeInfo> infos = catalog.getFeatureTypeInfos();
         ArrayList requested = new ArrayList();
 
         if (!names.isEmpty()) {
-O: 
             for (Iterator t = names.iterator(); t.hasNext();) {
                 QName name = (QName) t.next();
 
-                for (Iterator h = infos.iterator(); h.hasNext();) {
-                    FeatureTypeInfo meta = (FeatureTypeInfo) h.next();
-                    if(!meta.isEnabled())
-                        continue;
-                    
-                    String namespace = meta.getNameSpace().getURI();
-                    String prefix = meta.getNameSpace().getPrefix();
-                    String local = meta.getTypeName();
+                String prefixedName = name.getPrefix() + ":" + name.getLocalPart();
 
-                    if (local.equals( name.getLocalPart() ) && 
-                            //match on uri or prefix (GEOS-2401)
-                            (namespace.equals(name.getNamespaceURI()) || prefix.equals( name.getPrefix()) ) ){
-                        //found, continue on and keep this handle in list
-                        requested.add(meta);
-
-                        continue O;
+                FeatureTypeInfo meta = infos.get(prefixedName);
+                if(meta == null){
+                    // not found
+                    String msg = "Could not find type: " + name;
+                    if (citeConformance) {
+                        msg += ". \nStrict WFS protocol conformance is being applied.\n"
+                            + "Make sure the type name is correctly qualified";
                     }
+                    throw new WFSException(msg);
+                } else if (meta.isEnabled()) {
+                    requested.add(meta);
                 }
-
-                //not found
-                String msg = "Could not find type: " + name;
-                if (citeConformance) {
-                    msg += ". \nStrict WFS protocol conformance is being applied.\n"
-                            + "Make sure the type name is correctly qualified";
-                }
-                throw new WFSException(msg);
             }
         } else {
             //if there are no specific requested types then get all the ones that
             //are enabled
-            for (Iterator it = infos.iterator(); it.hasNext();) {
+            for (Iterator it = infos.values().iterator(); it.hasNext();) {
                 FeatureTypeInfo ftInfo = (FeatureTypeInfo) it.next();
                 if(ftInfo.isEnabled())
                     requested.add(ftInfo);
Index: wfs/src/main/java/org/geoserver/wfs/xml/v1_0_0/WFSConfiguration.java
===================================================================
--- wfs/src/main/java/org/geoserver/wfs/xml/v1_0_0/WFSConfiguration.java	(revision 14791)
+++ wfs/src/main/java/org/geoserver/wfs/xml/v1_0_0/WFSConfiguration.java	(working copy)
@@ -13,6 +13,8 @@
 
 import net.opengis.ows10.Ows10Factory;
 import net.opengis.wfs.WfsFactory;
+
+import org.acegisecurity.AccessDeniedException;
 import org.eclipse.xsd.util.XSDSchemaLocationResolver;
 import org.geoserver.wfs.xml.FeatureTypeSchemaBuilder;
 import org.geoserver.wfs.xml.PropertyTypePropertyExtractor;
@@ -133,6 +135,7 @@
         Collection featureTypes = catalog.getFeatureTypeInfos().values();
 
         for (Iterator f = featureTypes.iterator(); f.hasNext();) {
+            try {
             FeatureTypeInfo meta = (FeatureTypeInfo) f.next();
             if ( !meta.isEnabled() ) {
                 continue;
@@ -150,6 +153,9 @@
             
 
             featureTypeCache.put(featureType);
+            } catch (AccessDeniedException e) {
+                // Ignore featureType
+            }
         }
     }
 
Index: wfs/src/main/java/org/geoserver/wfs/xml/FeatureTypeSchemaBuilder.java
===================================================================
--- wfs/src/main/java/org/geoserver/wfs/xml/FeatureTypeSchemaBuilder.java	(revision 14791)
+++ wfs/src/main/java/org/geoserver/wfs/xml/FeatureTypeSchemaBuilder.java	(working copy)
@@ -4,6 +4,7 @@
  */
 package org.geoserver.wfs.xml;
 
+import org.acegisecurity.AccessDeniedException;
 import org.eclipse.xsd.XSDComplexTypeDefinition;
 import org.eclipse.xsd.XSDCompositor;
 import org.eclipse.xsd.XSDDerivationMethod;
@@ -200,8 +201,12 @@
         Collection featureTypeInfos = catalog.getFeatureTypeInfos().values();
 
         for (Iterator i = featureTypeInfos.iterator(); i.hasNext();) {
-            FeatureTypeInfo meta = (FeatureTypeInfo) i.next();
-            
+            final FeatureTypeInfo meta;
+            try{
+                meta = (FeatureTypeInfo) i.next();
+            }catch(AccessDeniedException e) {
+                continue;
+            }
             // don't build schemas for disabled feature types
             if(!meta.isEnabled())
                 continue;
Index: wms/src/main/java/org/vfny/geoserver/global/WMS.java
===================================================================
--- wms/src/main/java/org/vfny/geoserver/global/WMS.java	(revision 14791)
+++ wms/src/main/java/org/vfny/geoserver/global/WMS.java	(working copy)
@@ -9,6 +9,9 @@
 import org.geoserver.catalog.ResourceInfo;
 import org.geoserver.catalog.StyleInfo;
 import org.geoserver.config.ServiceInfo;
+import org.geoserver.security.collection.Entry;
+import org.geoserver.security.collection.KeyValueMappingStrategy;
+import org.geoserver.security.collection.SecureCollection;
 import org.geoserver.wfs.WFS;
 import org.geoserver.wfs.WFSInfo;
 import org.geoserver.wms.WMSInfo;
@@ -443,17 +446,20 @@
     }
 
     public Map getBaseMapLayers() {
-        HashMap baseLayers = new HashMap();
-        for ( LayerGroupInfo map : gs.getCatalog().getLayerGroups() ) {
-            StringBuffer layers = new StringBuffer();
-            for ( LayerInfo l : map.getLayers() ) {
-                layers.append( l.getResource().getPrefixedName() ).append( "," );
+        
+        return SecureCollection.toMap(gs.getCatalog().getLayerGroups(), 
+            new KeyValueMappingStrategy<LayerGroupInfo, String, String>() {
+
+                public Entry<String, String> map(LayerGroupInfo map) {
+                    StringBuffer layers = new StringBuffer();
+                    for ( LayerInfo l : map.getLayers() ) {
+                        layers.append( l.getResource().getPrefixedName() ).append( "," );
+                    }
+                    layers.setLength( layers.length() - 1 );
+                    return Entry.entry( map.getName(), layers.toString() );
+                }
             }
-            layers.setLength( layers.length() - 1 );
-            baseLayers.put( map.getName(), layers.toString() );
-        }
-        return baseLayers;
-        //return baseMapLayers != null ? baseMapLayers : Collections.EMPTY_MAP;
+        );
     }
 
     public void setBaseMapLayers(Map layers) {
@@ -495,24 +501,26 @@
     }
 
     public Map getBaseMapStyles() {
-        HashMap baseMapStyles = new HashMap();
-        for ( LayerGroupInfo map : gs.getCatalog().getLayerGroups() ) {
-            String rawStyleList = (String) map.getMetadata().get( "rawStyleList");
-            if ( rawStyleList != null ) {
-                baseMapStyles.put( map.getName(), rawStyleList );
-            }
-            else {
-                //generate it from the actual style list
-                StringBuffer styles = new StringBuffer();
-                for ( StyleInfo s : map.getStyles() ) {
-                    styles.append( s.getName() ).append( "," );
+        return SecureCollection.toMap(gs.getCatalog().getLayerGroups(), 
+            new KeyValueMappingStrategy<LayerGroupInfo, String, String>() {
+                public Entry<String, String> map(LayerGroupInfo map) {
+                    String rawStyleList = (String) map.getMetadata().get( "rawStyleList");
+                    Entry<String,String> result;
+                    if ( rawStyleList != null ) {
+                        result = Entry.entry(map.getName(), rawStyleList);
+                    } else {
+                        //generate it from the actual style list
+                        StringBuffer styles = new StringBuffer();
+                        for ( StyleInfo s : map.getStyles() ) {
+                            styles.append( s.getName() ).append( "," );
+                        }
+                        styles.setLength( styles.length() - 1 );
+                        result = Entry.entry(map.getName(), styles.toString());
+                    }
+                    return result;
                 }
-                styles.setLength( styles.length() - 1 );
-                baseMapStyles.put( map.getName(), styles.toString() );
             }
-        }
-        return baseMapStyles;
-        //return baseMapStyles != null ? baseMapStyles : Collections.EMPTY_MAP;
+        );
     }
 
     public void setBaseMapStyles(Map styles) {
@@ -563,12 +571,16 @@
     }
 
     public Map getBaseMapEnvelopes() {
-        HashMap baseMapEnvelopes = new HashMap();
-        for ( LayerGroupInfo map : gs.getCatalog().getLayerGroups() ) {
-            baseMapEnvelopes.put( map.getName(), new GeneralEnvelope( map.getBounds() ) );
-        }
-        return baseMapEnvelopes;
-        //return baseMapEnvelopes != null ? baseMapEnvelopes : Collections.EMPTY_MAP;
+        List<LayerGroupInfo> layerGroups = gs.getCatalog().getLayerGroups();
+        
+        
+        return SecureCollection.toMap(layerGroups,
+            new KeyValueMappingStrategy<LayerGroupInfo, String, GeneralEnvelope>() {
+                public Entry<String, GeneralEnvelope>  map(LayerGroupInfo from) {
+                    return Entry.entry (from.getName(), new GeneralEnvelope(from.getBounds()));
+                }
+            }
+        );
     }
 
     public void getBaseMapEnvelopes(Map envelopes) {
Index: rest/pom.xml
===================================================================
--- rest/pom.xml	(revision 14791)
+++ rest/pom.xml	(working copy)
@@ -18,12 +18,18 @@
   <name>Geoserver REST Support Code</name>
 
   <repositories>
+      <repository>
+         <id>codehaus</id>
+         <name>codehaus</name>
+         <url>http://repository.codehaus.org/</url>
+      </repository>
+      <repository>
+         <id>restlet</id>
+         <name>restlet</name>
+         <url>http://maven.restlet.org/</url>
+      </repository>
+    
     <repository>
-       <id>codehaus</id>
-       <name>codehaus</name>
-       <url>http://repository.codehaus.org/</url>
-    </repository>
-    <repository>
        <id>refractions</id>
        <name>refractions</name>
        <url>http://lists.refractions.net/m2</url>
