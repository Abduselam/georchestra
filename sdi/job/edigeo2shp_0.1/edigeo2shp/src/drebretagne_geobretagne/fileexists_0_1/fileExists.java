// ============================================================================
//
// Copyright (c) 2005-2009, Talend Inc.
//
// This source code has been automatically generated by Spatial Data Integrator Powered by Talend
// / JobDesigner (CodeGenerator version 2.2.0.200910202312).
// You can find more information about Talend products at www.talend.com.
// You may distribute this code under the terms of the GNU LGPL license
// (http://www.gnu.org/licenses/lgpl.html).
//
// ============================================================================ 
package drebretagne_geobretagne.fileexists_0_1;

import routines.DataOperation;
import routines.GeoOperation;
import routines.GeometryOperation;
import routines.Mathematical;
import routines.Numeric;
import routines.OpenStreetMap;
import routines.Relational;
import routines.StringHandling;
import routines.TalendDataGenerator;
import routines.TalendDate;
import routines.TalendString;
import routines.system.*;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.List;
import java.math.BigDecimal;
import java.io.ByteArrayOutputStream;
import java.io.ByteArrayInputStream;
import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.ObjectOutputStream;
import java.io.ObjectInputStream;
import java.io.IOException;
import java.util.Comparator;
import org.talend.sdi.geometry.Geometry;

/**
 * Job: fileExists Purpose: <br>
 * Description: <br>
 * 
 * @author yjacolin@free.fr
 * @version 2.2.0.200910202312
 * @status
 */
public class fileExists {

	public final Object obj = new Object();
	// create and load default properties
	private java.util.Properties defaultProps = new java.util.Properties();

	// create application properties with default
	private class ContextProperties extends java.util.Properties {

		public ContextProperties(java.util.Properties properties) {
			super(properties);
		}

		public ContextProperties() {
			super();
		}

		public void synchronizeContext() {

			if (fileName != null) {

				this.setProperty("fileName", fileName.toString());

			}

			if (edigeoDir != null) {

				this.setProperty("edigeoDir", edigeoDir.toString());

			}

			if (exportDir != null) {

				this.setProperty("exportDir", exportDir.toString());

			}

			if (force != null) {

				this.setProperty("force", force.toString());

			}

			if (tmpDir != null) {

				this.setProperty("tmpDir", tmpDir.toString());

			}

		}

		public String fileName;
		public String edigeoDir;
		public String exportDir;
		public Boolean force;
		public String tmpDir;
	}

	private ContextProperties context = new ContextProperties();
	private final String jobVersion = "0.1";
	private final String jobName = "fileExists";
	private final String projectName = "DREBRETAGNE_GEOBRETAGNE";
	public Integer errorCode = null;
	private String currentComponent = "";
	private final java.util.Map<String, Long> start_Hash = new java.util.HashMap<String, Long>();
	private final java.util.Map<String, Long> end_Hash = new java.util.HashMap<String, Long>();
	private final java.util.Map<String, Boolean> ok_Hash = new java.util.HashMap<String, Boolean>();
	private final java.util.Map<String, Object> globalMap = new java.util.HashMap<String, Object>();
	public final java.util.List<String[]> globalBuffer = new java.util.ArrayList<String[]>();

	LogCatcherUtils talendLogs_LOGS = new LogCatcherUtils();

	private final java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();
	private final java.io.PrintStream errorMessagePS = new java.io.PrintStream(
			new java.io.BufferedOutputStream(baos));

	public String getExceptionStackTrace() {
		errorMessagePS.flush();
		return baos.toString();
	}

	private class TalendException extends Exception {
		private java.util.Map<String, Object> globalMap = null;
		private Exception e = null;
		private String currentComponent = null;

		private TalendException(Exception e, String errorComponent,
				final java.util.Map<String, Object> globalMap) {
			this.currentComponent = errorComponent;
			this.globalMap = globalMap;
			this.e = e;
		}

		@Override
		public void printStackTrace() {
			if (!(e instanceof TalendException || e instanceof TDieException)) {
				globalMap.put(currentComponent + "_ERROR_MESSAGE", e
						.getMessage());
				System.err
						.println("Exception in component " + currentComponent);
			}
			if (!(e instanceof TDieException)) {
				if (e instanceof TalendException) {
					e.printStackTrace();
				} else {
					e.printStackTrace();
					e.printStackTrace(errorMessagePS);
				}
			}
			if (!(e instanceof TalendException)) {
				try {
					for (java.lang.reflect.Method m : this.getClass()
							.getEnclosingClass().getMethods()) {
						if (m.getName().compareTo(currentComponent + "_error") == 0) {
							m.invoke(fileExists.this, new Object[] { e,
									currentComponent, globalMap });
							break;
						}
					}

					if (!(e instanceof TDieException)) {
						talendLogs_LOGS.addMessage("Java Exception",
								currentComponent, 6, e.getClass().getName()
										+ ":" + e.getMessage(), 1);
						talendLogs_LOGSProcess(globalMap);
					}
				} catch (java.lang.SecurityException e) {
					this.e.printStackTrace();
				} catch (java.lang.IllegalArgumentException e) {
					this.e.printStackTrace();
				} catch (java.lang.IllegalAccessException e) {
					this.e.printStackTrace();
				} catch (java.lang.reflect.InvocationTargetException e) {
					this.e.printStackTrace();
				} catch (TalendException e) {
					// do nothing
				}

			}
		}
	}

	public void tForeach_1_error(Exception exception, String errorComponent,
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tForeach_1", System.currentTimeMillis());
		tForeach_1_onSubJobError(exception, errorComponent, globalMap);
	}

	public void tFileExist_1_error(Exception exception, String errorComponent,
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tFileExist_1", System.currentTimeMillis());
		tForeach_1_onSubJobError(exception, errorComponent, globalMap);
	}

	public void tDie_1_error(Exception exception, String errorComponent,
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tDie_1", System.currentTimeMillis());
		tDie_1_onSubJobError(exception, errorComponent, globalMap);
	}

	public void tFileDelete_1_error(Exception exception, String errorComponent,
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tFileDelete_1", System.currentTimeMillis());
		tFileDelete_1_onSubJobError(exception, errorComponent, globalMap);
	}

	public void tFileDelete_2_error(Exception exception, String errorComponent,
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tFileDelete_2", System.currentTimeMillis());
		tFileDelete_2_onSubJobError(exception, errorComponent, globalMap);
	}

	public void tFileDelete_3_error(Exception exception, String errorComponent,
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tFileDelete_3", System.currentTimeMillis());
		tFileDelete_3_onSubJobError(exception, errorComponent, globalMap);
	}

	public void tFileDelete_4_error(Exception exception, String errorComponent,
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("tFileDelete_4", System.currentTimeMillis());
		tFileDelete_4_onSubJobError(exception, errorComponent, globalMap);
	}

	public void talendLogs_LOGS_error(Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("talendLogs_LOGS", System.currentTimeMillis());
		talendLogs_LOGS_onSubJobError(exception, errorComponent, globalMap);
	}

	public void talendLogs_CONSOLE_error(Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {
		end_Hash.put("talendLogs_CONSOLE", System.currentTimeMillis());
		talendLogs_LOGS_onSubJobError(exception, errorComponent, globalMap);
	}

	public void tForeach_1_onSubJobError(Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {

		resumeUtil.addLog("SYSTEM_LOG", "NODE:" + errorComponent, "", Thread
				.currentThread().getId()
				+ "", "FATAL", "", exception.getMessage(), ResumeUtil
				.getExceptionStackTrace(exception));

	}

	public void tDie_1_onSubJobError(Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {

		resumeUtil.addLog("SYSTEM_LOG", "NODE:" + errorComponent, "", Thread
				.currentThread().getId()
				+ "", "FATAL", "", exception.getMessage(), ResumeUtil
				.getExceptionStackTrace(exception));

	}

	public void tFileDelete_1_onSubJobError(Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {

		resumeUtil.addLog("SYSTEM_LOG", "NODE:" + errorComponent, "", Thread
				.currentThread().getId()
				+ "", "FATAL", "", exception.getMessage(), ResumeUtil
				.getExceptionStackTrace(exception));

	}

	public void tFileDelete_2_onSubJobError(Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {

		resumeUtil.addLog("SYSTEM_LOG", "NODE:" + errorComponent, "", Thread
				.currentThread().getId()
				+ "", "FATAL", "", exception.getMessage(), ResumeUtil
				.getExceptionStackTrace(exception));

	}

	public void tFileDelete_3_onSubJobError(Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {

		resumeUtil.addLog("SYSTEM_LOG", "NODE:" + errorComponent, "", Thread
				.currentThread().getId()
				+ "", "FATAL", "", exception.getMessage(), ResumeUtil
				.getExceptionStackTrace(exception));

	}

	public void tFileDelete_4_onSubJobError(Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {

		resumeUtil.addLog("SYSTEM_LOG", "NODE:" + errorComponent, "", Thread
				.currentThread().getId()
				+ "", "FATAL", "", exception.getMessage(), ResumeUtil
				.getExceptionStackTrace(exception));

	}

	public void talendLogs_LOGS_onSubJobError(Exception exception,
			String errorComponent, final java.util.Map<String, Object> globalMap)
			throws TalendException {

		resumeUtil.addLog("SYSTEM_LOG", "NODE:" + errorComponent, "", Thread
				.currentThread().getId()
				+ "", "FATAL", "", exception.getMessage(), ResumeUtil
				.getExceptionStackTrace(exception));

	}

	public void tForeach_1Process(final java.util.Map<String, Object> globalMap)
			throws TalendException {
		globalMap.put("tForeach_1_SUBPROCESS_STATE", 0);

		String currentComponent = "";

		try {

			String currentMethodName = new Exception().getStackTrace()[0]
					.getMethodName();
			boolean resumeIt = currentMethodName.equals(resumeEntryMethodName);
			if (resumeEntryMethodName == null || resumeIt || globalResumeTicket) {// start
																					// the
																					// resume

				/**
				 * [tForeach_1 begin ] start
				 */

				int NB_ITERATE_tFileExist_1 = 0; // for statistics

				ok_Hash.put("tForeach_1", false);
				start_Hash.put("tForeach_1", System.currentTimeMillis());
				currentComponent = "tForeach_1";

				int tos_count_tForeach_1 = 0;

				Object[] values_tForeach_1 = new Object[] { "batiment",
						"borne", "charge", "commune", "lieudit", "numvoie",
						"parcelle", "pointcst", "ptcanv", "section",
						"subdfisc", "subdsect", "symblim", "tline", "tpoint",
						"tronfluv", "tronroute", "tsurf", "voiep",
						"zoncommuni", };

				for (Object tmp_tForeach_1 : values_tForeach_1) {
					globalMap.put("tForeach_1_CURRENT_VALUE", tmp_tForeach_1);

					/**
					 * [tForeach_1 begin ] stop
					 */
					/**
					 * [tForeach_1 main ] start
					 */

					currentComponent = "tForeach_1";

					tos_count_tForeach_1++;

					/**
					 * [tForeach_1 main ] stop
					 */
					NB_ITERATE_tFileExist_1++;

					/**
					 * [tFileExist_1 begin ] start
					 */

					ok_Hash.put("tFileExist_1", false);
					start_Hash.put("tFileExist_1", System.currentTimeMillis());
					currentComponent = "tFileExist_1";

					int tos_count_tFileExist_1 = 0;

					/**
					 * [tFileExist_1 begin ] stop
					 */
					/**
					 * [tFileExist_1 main ] start
					 */

					currentComponent = "tFileExist_1";

					java.io.File file_tFileExist_1 = new java.io.File(
							context.exportDir
									+ "/"
									+ context.fileName
									+ "_"
									+ ((String) globalMap
											.get("tForeach_1_CURRENT_VALUE"))
									+ ".shp");
					if (!file_tFileExist_1.exists()) {
						globalMap.put("tFileExist_1_EXISTS", false);
					} else {
						globalMap.put("tFileExist_1_EXISTS", true);
					}

					globalMap.put("tFileExist_1_FILENAME", context.exportDir
							+ "/"
							+ context.fileName
							+ "_"
							+ ((String) globalMap
									.get("tForeach_1_CURRENT_VALUE")) + ".shp");

					tos_count_tFileExist_1++;

					/**
					 * [tFileExist_1 main ] stop
					 */
					/**
					 * [tFileExist_1 end ] start
					 */

					currentComponent = "tFileExist_1";

					ok_Hash.put("tFileExist_1", true);
					end_Hash.put("tFileExist_1", System.currentTimeMillis());

					if (((Boolean) globalMap.get("tFileExist_1_EXISTS")) == true
							&& context.force == false) {
						tDie_1Process(globalMap);
					}

					if ((context.force == true && ((Boolean) globalMap
							.get("tFileExist_1_EXISTS")) == true)) {
						tFileDelete_1Process(globalMap);
					}

					/**
					 * [tFileExist_1 end ] stop
					 */

					/**
					 * [tForeach_1 end ] start
					 */

					currentComponent = "tForeach_1";

				}

				ok_Hash.put("tForeach_1", true);
				end_Hash.put("tForeach_1", System.currentTimeMillis());

				/**
				 * [tForeach_1 end ] stop
				 */

				globalResumeTicket = true;

			}// end the resume

		} catch (Exception e) {

			throw new TalendException(e, currentComponent, globalMap);

		}

		globalMap.put("tForeach_1_SUBPROCESS_STATE", 1);
	}

	public void tDie_1Process(final java.util.Map<String, Object> globalMap)
			throws TalendException {
		globalMap.put("tDie_1_SUBPROCESS_STATE", 0);

		String currentComponent = "";

		try {

			String currentMethodName = new Exception().getStackTrace()[0]
					.getMethodName();
			boolean resumeIt = currentMethodName.equals(resumeEntryMethodName);
			if (resumeEntryMethodName == null || resumeIt || globalResumeTicket) {// start
																					// the
																					// resume

				/**
				 * [tDie_1 begin ] start
				 */

				ok_Hash.put("tDie_1", false);
				start_Hash.put("tDie_1", System.currentTimeMillis());
				currentComponent = "tDie_1";

				int tos_count_tDie_1 = 0;

				/**
				 * [tDie_1 begin ] stop
				 */
				/**
				 * [tDie_1 main ] start
				 */

				currentComponent = "tDie_1";

				talendLogs_LOGS
						.addMessage(
								"tDie",
								"tDie_1",
								5,
								"Les fichiers existents et ne doivent pas être effacés. Ajouter le paramètre force=true pour forcer la supression des fichiers.",
								4);
				talendLogs_LOGSProcess(globalMap);

				System.err
						.println("Les fichiers existents et ne doivent pas être effacés. Ajouter le paramètre force=true pour forcer la supression des fichiers.");
				currentComponent = "tDie_1";
				errorCode = new Integer(4);

				if (true) {
					throw new TDieException();
				}

				tos_count_tDie_1++;

				/**
				 * [tDie_1 main ] stop
				 */
				/**
				 * [tDie_1 end ] start
				 */

				currentComponent = "tDie_1";

				ok_Hash.put("tDie_1", true);
				end_Hash.put("tDie_1", System.currentTimeMillis());

				/**
				 * [tDie_1 end ] stop
				 */

				globalResumeTicket = true;

			}// end the resume

		} catch (Exception e) {

			throw new TalendException(e, currentComponent, globalMap);

		}

		globalMap.put("tDie_1_SUBPROCESS_STATE", 1);
	}

	public void tFileDelete_1Process(
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		globalMap.put("tFileDelete_1_SUBPROCESS_STATE", 0);

		String currentComponent = "";

		try {

			String currentMethodName = new Exception().getStackTrace()[0]
					.getMethodName();
			boolean resumeIt = currentMethodName.equals(resumeEntryMethodName);
			if (resumeEntryMethodName == null || resumeIt || globalResumeTicket) {// start
																					// the
																					// resume

				/**
				 * [tFileDelete_1 begin ] start
				 */

				ok_Hash.put("tFileDelete_1", false);
				start_Hash.put("tFileDelete_1", System.currentTimeMillis());
				currentComponent = "tFileDelete_1";

				int tos_count_tFileDelete_1 = 0;

				/**
				 * [tFileDelete_1 begin ] stop
				 */
				/**
				 * [tFileDelete_1 main ] start
				 */

				currentComponent = "tFileDelete_1";

				class DeleteFoldertFileDelete_1 {
					/**
					 * delete all the sub-files in 'file'
					 * 
					 * @param file
					 */
					public void delete(java.io.File file) {
						// TODO Auto-generated method stub
						java.io.File[] files = file.listFiles();
						for (int i = 0; i < files.length; i++) {
							if (files[i].isFile()) {
								files[i].delete();
							} else if (files[i].isDirectory()) {
								if (!files[i].delete()) {
									delete(files[i]);
								}
							}
						}
						deleteDirectory(file);
						file.delete();
					}

					/**
					 * delete all the sub-folders in 'file'
					 * 
					 * @param file
					 */
					private void deleteDirectory(java.io.File file) {
						// TODO Auto-generated method stub
						java.io.File[] filed = file.listFiles();
						for (int i = 0; i < filed.length; i++) {
							deleteDirectory(filed[i]);
							filed[i].delete();
						}
					}

				}
				java.io.File file_tFileDelete_1 = new java.io.File(
						context.exportDir
								+ "/"
								+ context.fileName
								+ "_"
								+ ((String) globalMap
										.get("tForeach_1_CURRENT_VALUE"))
								+ ".shp");
				if (file_tFileDelete_1.exists() && file_tFileDelete_1.isFile()) {
					file_tFileDelete_1.delete();
				} else {
					throw new RuntimeException(
							"File does not exists or is invalid");
				}
				globalMap.put("tFileDelete_1_DELETE_PATH", context.exportDir
						+ "/" + context.fileName + "_"
						+ ((String) globalMap.get("tForeach_1_CURRENT_VALUE"))
						+ ".shp");

				tos_count_tFileDelete_1++;

				/**
				 * [tFileDelete_1 main ] stop
				 */
				/**
				 * [tFileDelete_1 end ] start
				 */

				currentComponent = "tFileDelete_1";

				ok_Hash.put("tFileDelete_1", true);
				end_Hash.put("tFileDelete_1", System.currentTimeMillis());

				tFileDelete_2Process(globalMap);

				/**
				 * [tFileDelete_1 end ] stop
				 */

				globalResumeTicket = true;

			}// end the resume

		} catch (Exception e) {

			throw new TalendException(e, currentComponent, globalMap);

		}

		globalMap.put("tFileDelete_1_SUBPROCESS_STATE", 1);
	}

	public void tFileDelete_2Process(
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		globalMap.put("tFileDelete_2_SUBPROCESS_STATE", 0);

		String currentComponent = "";

		try {

			String currentMethodName = new Exception().getStackTrace()[0]
					.getMethodName();
			boolean resumeIt = currentMethodName.equals(resumeEntryMethodName);
			if (resumeEntryMethodName == null || resumeIt || globalResumeTicket) {// start
																					// the
																					// resume

				/**
				 * [tFileDelete_2 begin ] start
				 */

				ok_Hash.put("tFileDelete_2", false);
				start_Hash.put("tFileDelete_2", System.currentTimeMillis());
				currentComponent = "tFileDelete_2";

				int tos_count_tFileDelete_2 = 0;

				/**
				 * [tFileDelete_2 begin ] stop
				 */
				/**
				 * [tFileDelete_2 main ] start
				 */

				currentComponent = "tFileDelete_2";

				class DeleteFoldertFileDelete_2 {
					/**
					 * delete all the sub-files in 'file'
					 * 
					 * @param file
					 */
					public void delete(java.io.File file) {
						// TODO Auto-generated method stub
						java.io.File[] files = file.listFiles();
						for (int i = 0; i < files.length; i++) {
							if (files[i].isFile()) {
								files[i].delete();
							} else if (files[i].isDirectory()) {
								if (!files[i].delete()) {
									delete(files[i]);
								}
							}
						}
						deleteDirectory(file);
						file.delete();
					}

					/**
					 * delete all the sub-folders in 'file'
					 * 
					 * @param file
					 */
					private void deleteDirectory(java.io.File file) {
						// TODO Auto-generated method stub
						java.io.File[] filed = file.listFiles();
						for (int i = 0; i < filed.length; i++) {
							deleteDirectory(filed[i]);
							filed[i].delete();
						}
					}

				}
				java.io.File file_tFileDelete_2 = new java.io.File(
						context.exportDir
								+ "/"
								+ context.fileName
								+ "_"
								+ ((String) globalMap
										.get("tForeach_1_CURRENT_VALUE"))
								+ ".dbf");
				if (file_tFileDelete_2.exists() && file_tFileDelete_2.isFile()) {
					file_tFileDelete_2.delete();
				} else {
					throw new RuntimeException(
							"File does not exists or is invalid");
				}
				globalMap.put("tFileDelete_2_DELETE_PATH", context.exportDir
						+ "/" + context.fileName + "_"
						+ ((String) globalMap.get("tForeach_1_CURRENT_VALUE"))
						+ ".dbf");

				tos_count_tFileDelete_2++;

				/**
				 * [tFileDelete_2 main ] stop
				 */
				/**
				 * [tFileDelete_2 end ] start
				 */

				currentComponent = "tFileDelete_2";

				ok_Hash.put("tFileDelete_2", true);
				end_Hash.put("tFileDelete_2", System.currentTimeMillis());

				tFileDelete_3Process(globalMap);

				/**
				 * [tFileDelete_2 end ] stop
				 */

				globalResumeTicket = true;

			}// end the resume

		} catch (Exception e) {

			throw new TalendException(e, currentComponent, globalMap);

		}

		globalMap.put("tFileDelete_2_SUBPROCESS_STATE", 1);
	}

	public void tFileDelete_3Process(
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		globalMap.put("tFileDelete_3_SUBPROCESS_STATE", 0);

		String currentComponent = "";

		try {

			String currentMethodName = new Exception().getStackTrace()[0]
					.getMethodName();
			boolean resumeIt = currentMethodName.equals(resumeEntryMethodName);
			if (resumeEntryMethodName == null || resumeIt || globalResumeTicket) {// start
																					// the
																					// resume

				/**
				 * [tFileDelete_3 begin ] start
				 */

				ok_Hash.put("tFileDelete_3", false);
				start_Hash.put("tFileDelete_3", System.currentTimeMillis());
				currentComponent = "tFileDelete_3";

				int tos_count_tFileDelete_3 = 0;

				/**
				 * [tFileDelete_3 begin ] stop
				 */
				/**
				 * [tFileDelete_3 main ] start
				 */

				currentComponent = "tFileDelete_3";

				class DeleteFoldertFileDelete_3 {
					/**
					 * delete all the sub-files in 'file'
					 * 
					 * @param file
					 */
					public void delete(java.io.File file) {
						// TODO Auto-generated method stub
						java.io.File[] files = file.listFiles();
						for (int i = 0; i < files.length; i++) {
							if (files[i].isFile()) {
								files[i].delete();
							} else if (files[i].isDirectory()) {
								if (!files[i].delete()) {
									delete(files[i]);
								}
							}
						}
						deleteDirectory(file);
						file.delete();
					}

					/**
					 * delete all the sub-folders in 'file'
					 * 
					 * @param file
					 */
					private void deleteDirectory(java.io.File file) {
						// TODO Auto-generated method stub
						java.io.File[] filed = file.listFiles();
						for (int i = 0; i < filed.length; i++) {
							deleteDirectory(filed[i]);
							filed[i].delete();
						}
					}

				}
				java.io.File file_tFileDelete_3 = new java.io.File(
						context.exportDir
								+ "/"
								+ context.fileName
								+ "_"
								+ ((String) globalMap
										.get("tForeach_1_CURRENT_VALUE"))
								+ ".shx");
				if (file_tFileDelete_3.exists() && file_tFileDelete_3.isFile()) {
					file_tFileDelete_3.delete();
				} else {
					throw new RuntimeException(
							"File does not exists or is invalid");
				}
				globalMap.put("tFileDelete_3_DELETE_PATH", context.exportDir
						+ "/" + context.fileName + "_"
						+ ((String) globalMap.get("tForeach_1_CURRENT_VALUE"))
						+ ".shx");

				tos_count_tFileDelete_3++;

				/**
				 * [tFileDelete_3 main ] stop
				 */
				/**
				 * [tFileDelete_3 end ] start
				 */

				currentComponent = "tFileDelete_3";

				ok_Hash.put("tFileDelete_3", true);
				end_Hash.put("tFileDelete_3", System.currentTimeMillis());

				tFileDelete_4Process(globalMap);

				/**
				 * [tFileDelete_3 end ] stop
				 */

				globalResumeTicket = true;

			}// end the resume

		} catch (Exception e) {

			throw new TalendException(e, currentComponent, globalMap);

		}

		globalMap.put("tFileDelete_3_SUBPROCESS_STATE", 1);
	}

	public void tFileDelete_4Process(
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		globalMap.put("tFileDelete_4_SUBPROCESS_STATE", 0);

		String currentComponent = "";

		try {

			String currentMethodName = new Exception().getStackTrace()[0]
					.getMethodName();
			boolean resumeIt = currentMethodName.equals(resumeEntryMethodName);
			if (resumeEntryMethodName == null || resumeIt || globalResumeTicket) {// start
																					// the
																					// resume

				/**
				 * [tFileDelete_4 begin ] start
				 */

				ok_Hash.put("tFileDelete_4", false);
				start_Hash.put("tFileDelete_4", System.currentTimeMillis());
				currentComponent = "tFileDelete_4";

				int tos_count_tFileDelete_4 = 0;

				/**
				 * [tFileDelete_4 begin ] stop
				 */
				/**
				 * [tFileDelete_4 main ] start
				 */

				currentComponent = "tFileDelete_4";

				class DeleteFoldertFileDelete_4 {
					/**
					 * delete all the sub-files in 'file'
					 * 
					 * @param file
					 */
					public void delete(java.io.File file) {
						// TODO Auto-generated method stub
						java.io.File[] files = file.listFiles();
						for (int i = 0; i < files.length; i++) {
							if (files[i].isFile()) {
								files[i].delete();
							} else if (files[i].isDirectory()) {
								if (!files[i].delete()) {
									delete(files[i]);
								}
							}
						}
						deleteDirectory(file);
						file.delete();
					}

					/**
					 * delete all the sub-folders in 'file'
					 * 
					 * @param file
					 */
					private void deleteDirectory(java.io.File file) {
						// TODO Auto-generated method stub
						java.io.File[] filed = file.listFiles();
						for (int i = 0; i < filed.length; i++) {
							deleteDirectory(filed[i]);
							filed[i].delete();
						}
					}

				}
				java.io.File file_tFileDelete_4 = new java.io.File(
						context.exportDir
								+ "/"
								+ context.fileName
								+ "_"
								+ ((String) globalMap
										.get("tForeach_1_CURRENT_VALUE"))
								+ ".prj");
				if (file_tFileDelete_4.exists() && file_tFileDelete_4.isFile()) {
					file_tFileDelete_4.delete();
				} else {
					throw new RuntimeException(
							"File does not exists or is invalid");
				}
				globalMap.put("tFileDelete_4_DELETE_PATH", context.exportDir
						+ "/" + context.fileName + "_"
						+ ((String) globalMap.get("tForeach_1_CURRENT_VALUE"))
						+ ".prj");

				tos_count_tFileDelete_4++;

				/**
				 * [tFileDelete_4 main ] stop
				 */
				/**
				 * [tFileDelete_4 end ] start
				 */

				currentComponent = "tFileDelete_4";

				ok_Hash.put("tFileDelete_4", true);
				end_Hash.put("tFileDelete_4", System.currentTimeMillis());

				/**
				 * [tFileDelete_4 end ] stop
				 */

				globalResumeTicket = true;

			}// end the resume

		} catch (Exception e) {

			throw new TalendException(e, currentComponent, globalMap);

		}

		globalMap.put("tFileDelete_4_SUBPROCESS_STATE", 1);
	}

	public static class row_talendLogs_LOGSStruct implements
			routines.system.IPersistableRow<row_talendLogs_LOGSStruct> {
		final static byte[] commonByteArrayLock = new byte[0];
		static byte[] commonByteArray = new byte[0];

		public java.util.Date moment;

		public java.util.Date getMoment() {
			return this.moment;
		}

		public String pid;

		public String getPid() {
			return this.pid;
		}

		public String root_pid;

		public String getRoot_pid() {
			return this.root_pid;
		}

		public String father_pid;

		public String getFather_pid() {
			return this.father_pid;
		}

		public String project;

		public String getProject() {
			return this.project;
		}

		public String job;

		public String getJob() {
			return this.job;
		}

		public String context;

		public String getContext() {
			return this.context;
		}

		public Integer priority;

		public Integer getPriority() {
			return this.priority;
		}

		public String type;

		public String getType() {
			return this.type;
		}

		public String origin;

		public String getOrigin() {
			return this.origin;
		}

		public String message;

		public String getMessage() {
			return this.message;
		}

		public Integer code;

		public Integer getCode() {
			return this.code;
		}

		public void readData(ObjectInputStream dis) {

			synchronized (commonByteArrayLock) {

				try {

					int length = 0;

					length = dis.readByte();
					if (length == -1) {
						this.moment = null;
					} else {
						this.moment = new Date(dis.readLong());
					}

					length = dis.readInt();
					if (length == -1) {
						this.pid = null;
					} else {
						if (length > commonByteArray.length) {
							if (length < 1024 && commonByteArray.length == 0) {
								commonByteArray = new byte[1024];
							} else {
								commonByteArray = new byte[2 * length];
							}
						}
						dis.readFully(commonByteArray, 0, length);
						this.pid = new String(commonByteArray, 0, length);
					}

					length = dis.readInt();
					if (length == -1) {
						this.root_pid = null;
					} else {
						if (length > commonByteArray.length) {
							if (length < 1024 && commonByteArray.length == 0) {
								commonByteArray = new byte[1024];
							} else {
								commonByteArray = new byte[2 * length];
							}
						}
						dis.readFully(commonByteArray, 0, length);
						this.root_pid = new String(commonByteArray, 0, length);
					}

					length = dis.readInt();
					if (length == -1) {
						this.father_pid = null;
					} else {
						if (length > commonByteArray.length) {
							if (length < 1024 && commonByteArray.length == 0) {
								commonByteArray = new byte[1024];
							} else {
								commonByteArray = new byte[2 * length];
							}
						}
						dis.readFully(commonByteArray, 0, length);
						this.father_pid = new String(commonByteArray, 0, length);
					}

					length = dis.readInt();
					if (length == -1) {
						this.project = null;
					} else {
						if (length > commonByteArray.length) {
							if (length < 1024 && commonByteArray.length == 0) {
								commonByteArray = new byte[1024];
							} else {
								commonByteArray = new byte[2 * length];
							}
						}
						dis.readFully(commonByteArray, 0, length);
						this.project = new String(commonByteArray, 0, length);
					}

					length = dis.readInt();
					if (length == -1) {
						this.job = null;
					} else {
						if (length > commonByteArray.length) {
							if (length < 1024 && commonByteArray.length == 0) {
								commonByteArray = new byte[1024];
							} else {
								commonByteArray = new byte[2 * length];
							}
						}
						dis.readFully(commonByteArray, 0, length);
						this.job = new String(commonByteArray, 0, length);
					}

					length = dis.readInt();
					if (length == -1) {
						this.context = null;
					} else {
						if (length > commonByteArray.length) {
							if (length < 1024 && commonByteArray.length == 0) {
								commonByteArray = new byte[1024];
							} else {
								commonByteArray = new byte[2 * length];
							}
						}
						dis.readFully(commonByteArray, 0, length);
						this.context = new String(commonByteArray, 0, length);
					}

					length = dis.readByte();
					if (length == -1) {
						this.priority = null;
					} else {
						this.priority = dis.readInt();
					}

					length = dis.readInt();
					if (length == -1) {
						this.type = null;
					} else {
						if (length > commonByteArray.length) {
							if (length < 1024 && commonByteArray.length == 0) {
								commonByteArray = new byte[1024];
							} else {
								commonByteArray = new byte[2 * length];
							}
						}
						dis.readFully(commonByteArray, 0, length);
						this.type = new String(commonByteArray, 0, length);
					}

					length = dis.readInt();
					if (length == -1) {
						this.origin = null;
					} else {
						if (length > commonByteArray.length) {
							if (length < 1024 && commonByteArray.length == 0) {
								commonByteArray = new byte[1024];
							} else {
								commonByteArray = new byte[2 * length];
							}
						}
						dis.readFully(commonByteArray, 0, length);
						this.origin = new String(commonByteArray, 0, length);
					}

					length = dis.readInt();
					if (length == -1) {
						this.message = null;
					} else {
						if (length > commonByteArray.length) {
							if (length < 1024 && commonByteArray.length == 0) {
								commonByteArray = new byte[1024];
							} else {
								commonByteArray = new byte[2 * length];
							}
						}
						dis.readFully(commonByteArray, 0, length);
						this.message = new String(commonByteArray, 0, length);
					}

					length = dis.readByte();
					if (length == -1) {
						this.code = null;
					} else {
						this.code = dis.readInt();
					}

				} catch (IOException e) {
					throw new RuntimeException(e);

				}

			}

		}

		public void writeData(ObjectOutputStream dos) {
			try {

				// java.util.Date

				if (this.moment == null) {
					dos.writeByte(-1);
				} else {
					dos.writeByte(0);
					dos.writeLong(this.moment.getTime());
				}

				// String

				if (this.pid == null) {
					dos.writeInt(-1);
				} else {
					byte[] byteArray = this.pid.getBytes();
					dos.writeInt(byteArray.length);
					dos.write(byteArray);
				}

				// String

				if (this.root_pid == null) {
					dos.writeInt(-1);
				} else {
					byte[] byteArray = this.root_pid.getBytes();
					dos.writeInt(byteArray.length);
					dos.write(byteArray);
				}

				// String

				if (this.father_pid == null) {
					dos.writeInt(-1);
				} else {
					byte[] byteArray = this.father_pid.getBytes();
					dos.writeInt(byteArray.length);
					dos.write(byteArray);
				}

				// String

				if (this.project == null) {
					dos.writeInt(-1);
				} else {
					byte[] byteArray = this.project.getBytes();
					dos.writeInt(byteArray.length);
					dos.write(byteArray);
				}

				// String

				if (this.job == null) {
					dos.writeInt(-1);
				} else {
					byte[] byteArray = this.job.getBytes();
					dos.writeInt(byteArray.length);
					dos.write(byteArray);
				}

				// String

				if (this.context == null) {
					dos.writeInt(-1);
				} else {
					byte[] byteArray = this.context.getBytes();
					dos.writeInt(byteArray.length);
					dos.write(byteArray);
				}

				// Integer

				if (this.priority == null) {
					dos.writeByte(-1);
				} else {
					dos.writeByte(0);
					dos.writeInt(this.priority);
				}

				// String

				if (this.type == null) {
					dos.writeInt(-1);
				} else {
					byte[] byteArray = this.type.getBytes();
					dos.writeInt(byteArray.length);
					dos.write(byteArray);
				}

				// String

				if (this.origin == null) {
					dos.writeInt(-1);
				} else {
					byte[] byteArray = this.origin.getBytes();
					dos.writeInt(byteArray.length);
					dos.write(byteArray);
				}

				// String

				if (this.message == null) {
					dos.writeInt(-1);
				} else {
					byte[] byteArray = this.message.getBytes();
					dos.writeInt(byteArray.length);
					dos.write(byteArray);
				}

				// Integer

				if (this.code == null) {
					dos.writeByte(-1);
				} else {
					dos.writeByte(0);
					dos.writeInt(this.code);
				}

			} catch (IOException e) {
				throw new RuntimeException(e);
			}

		}

		public String toString() {

			StringBuilder sb = new StringBuilder();
			sb.append(super.toString());
			sb.append("[");

			sb.append("moment");
			sb.append("=");
			sb.append(String.valueOf(this.moment));

			sb.append(", ");

			sb.append("pid");
			sb.append("=");
			sb.append(String.valueOf(this.pid));

			sb.append(", ");

			sb.append("root_pid");
			sb.append("=");
			sb.append(String.valueOf(this.root_pid));

			sb.append(", ");

			sb.append("father_pid");
			sb.append("=");
			sb.append(String.valueOf(this.father_pid));

			sb.append(", ");

			sb.append("project");
			sb.append("=");
			sb.append(String.valueOf(this.project));

			sb.append(", ");

			sb.append("job");
			sb.append("=");
			sb.append(String.valueOf(this.job));

			sb.append(", ");

			sb.append("context");
			sb.append("=");
			sb.append(String.valueOf(this.context));

			sb.append(", ");

			sb.append("priority");
			sb.append("=");
			sb.append(String.valueOf(this.priority));

			sb.append(", ");

			sb.append("type");
			sb.append("=");
			sb.append(String.valueOf(this.type));

			sb.append(", ");

			sb.append("origin");
			sb.append("=");
			sb.append(String.valueOf(this.origin));

			sb.append(", ");

			sb.append("message");
			sb.append("=");
			sb.append(String.valueOf(this.message));

			sb.append(", ");

			sb.append("code");
			sb.append("=");
			sb.append(String.valueOf(this.code));

			sb.append("]");

			return sb.toString();
		}

		/**
		 * Compare keys
		 */
		public int compareTo(row_talendLogs_LOGSStruct other) {

			int returnValue = -1;

			return returnValue;
		}

		private int checkNullsAndCompare(Object object1, Object object2) {
			int returnValue = 0;
			if (object1 instanceof Comparable && object2 instanceof Comparable) {
				returnValue = ((Comparable) object1).compareTo(object2);
			} else if (object1 != null && object2 != null) {
				returnValue = compareStrings(object1.toString(), object2
						.toString());
			} else if (object1 == null && object2 != null) {
				returnValue = 1;
			} else if (object1 != null && object2 == null) {
				returnValue = -1;
			} else {
				returnValue = 0;
			}

			return returnValue;
		}

		private int compareStrings(String string1, String string2) {
			return string1.compareTo(string2);
		}

	}

	public void talendLogs_LOGSProcess(
			final java.util.Map<String, Object> globalMap)
			throws TalendException {
		globalMap.put("talendLogs_LOGS_SUBPROCESS_STATE", 0);

		String currentComponent = "";

		try {

			String currentMethodName = new Exception().getStackTrace()[0]
					.getMethodName();
			boolean resumeIt = currentMethodName.equals(resumeEntryMethodName);
			if (resumeEntryMethodName == null || resumeIt || globalResumeTicket) {// start
																					// the
																					// resume

				row_talendLogs_LOGSStruct row_talendLogs_LOGS = new row_talendLogs_LOGSStruct();

				/**
				 * [talendLogs_CONSOLE begin ] start
				 */

				ok_Hash.put("talendLogs_CONSOLE", false);
				start_Hash
						.put("talendLogs_CONSOLE", System.currentTimeMillis());
				currentComponent = "talendLogs_CONSOLE";

				int tos_count_talendLogs_CONSOLE = 0;

				// /////////////////////

				final String OUTPUT_FIELD_SEPARATOR_talendLogs_CONSOLE = "|";
				java.io.PrintStream consoleOut_talendLogs_CONSOLE = null;

				int nb_line_talendLogs_CONSOLE = 0;

				// /////////////////////

				/**
				 * [talendLogs_CONSOLE begin ] stop
				 */

				/**
				 * [talendLogs_LOGS begin ] start
				 */

				ok_Hash.put("talendLogs_LOGS", false);
				start_Hash.put("talendLogs_LOGS", System.currentTimeMillis());
				currentComponent = "talendLogs_LOGS";

				int tos_count_talendLogs_LOGS = 0;

				for (LogCatcherUtils.LogCatcherMessage lcm : talendLogs_LOGS
						.getMessages()) {
					row_talendLogs_LOGS.type = lcm.getType();
					row_talendLogs_LOGS.origin = (lcm.getOrigin() == null
							|| lcm.getOrigin().length() < 1 ? null : lcm
							.getOrigin());
					row_talendLogs_LOGS.priority = lcm.getPriority();
					row_talendLogs_LOGS.message = lcm.getMessage();
					row_talendLogs_LOGS.code = lcm.getCode();

					row_talendLogs_LOGS.moment = java.util.Calendar
							.getInstance().getTime();

					row_talendLogs_LOGS.pid = pid;
					row_talendLogs_LOGS.root_pid = rootPid;
					row_talendLogs_LOGS.father_pid = fatherPid;

					row_talendLogs_LOGS.project = projectName;
					row_talendLogs_LOGS.job = jobName;
					row_talendLogs_LOGS.context = contextStr;

					/**
					 * [talendLogs_LOGS begin ] stop
					 */
					/**
					 * [talendLogs_LOGS main ] start
					 */

					currentComponent = "talendLogs_LOGS";

					tos_count_talendLogs_LOGS++;

					/**
					 * [talendLogs_LOGS main ] stop
					 */

					/**
					 * [talendLogs_CONSOLE main ] start
					 */

					currentComponent = "talendLogs_CONSOLE";

					// /////////////////////

					StringBuilder strBuffer_talendLogs_CONSOLE = new StringBuilder();

					if (row_talendLogs_LOGS.moment != null) { //              

						strBuffer_talendLogs_CONSOLE.append(FormatterUtils
								.format_Date(row_talendLogs_LOGS.moment,
										"yyyy-MM-dd HH:mm:ss"));

					} //  			

					strBuffer_talendLogs_CONSOLE.append("|");

					if (row_talendLogs_LOGS.pid != null) { //              

						strBuffer_talendLogs_CONSOLE.append(String
								.valueOf(row_talendLogs_LOGS.pid));

					} //  			

					strBuffer_talendLogs_CONSOLE.append("|");

					if (row_talendLogs_LOGS.root_pid != null) { //              

						strBuffer_talendLogs_CONSOLE.append(String
								.valueOf(row_talendLogs_LOGS.root_pid));

					} //  			

					strBuffer_talendLogs_CONSOLE.append("|");

					if (row_talendLogs_LOGS.father_pid != null) { //              

						strBuffer_talendLogs_CONSOLE.append(String
								.valueOf(row_talendLogs_LOGS.father_pid));

					} //  			

					strBuffer_talendLogs_CONSOLE.append("|");

					if (row_talendLogs_LOGS.project != null) { //              

						strBuffer_talendLogs_CONSOLE.append(String
								.valueOf(row_talendLogs_LOGS.project));

					} //  			

					strBuffer_talendLogs_CONSOLE.append("|");

					if (row_talendLogs_LOGS.job != null) { //              

						strBuffer_talendLogs_CONSOLE.append(String
								.valueOf(row_talendLogs_LOGS.job));

					} //  			

					strBuffer_talendLogs_CONSOLE.append("|");

					if (row_talendLogs_LOGS.context != null) { //              

						strBuffer_talendLogs_CONSOLE.append(String
								.valueOf(row_talendLogs_LOGS.context));

					} //  			

					strBuffer_talendLogs_CONSOLE.append("|");

					if (row_talendLogs_LOGS.priority != null) { //              

						strBuffer_talendLogs_CONSOLE.append(String
								.valueOf(row_talendLogs_LOGS.priority));

					} //  			

					strBuffer_talendLogs_CONSOLE.append("|");

					if (row_talendLogs_LOGS.type != null) { //              

						strBuffer_talendLogs_CONSOLE.append(String
								.valueOf(row_talendLogs_LOGS.type));

					} //  			

					strBuffer_talendLogs_CONSOLE.append("|");

					if (row_talendLogs_LOGS.origin != null) { //              

						strBuffer_talendLogs_CONSOLE.append(String
								.valueOf(row_talendLogs_LOGS.origin));

					} //  			

					strBuffer_talendLogs_CONSOLE.append("|");

					if (row_talendLogs_LOGS.message != null) { //              

						strBuffer_talendLogs_CONSOLE.append(String
								.valueOf(row_talendLogs_LOGS.message));

					} //  			

					strBuffer_talendLogs_CONSOLE.append("|");

					if (row_talendLogs_LOGS.code != null) { //              

						strBuffer_talendLogs_CONSOLE.append(String
								.valueOf(row_talendLogs_LOGS.code));

					} //  			

					if (globalMap.get("tLogRow_CONSOLE") != null) {
						consoleOut_talendLogs_CONSOLE = (java.io.PrintStream) globalMap
								.get("tLogRow_CONSOLE");
					} else {
						consoleOut_talendLogs_CONSOLE = new java.io.PrintStream(
								new java.io.BufferedOutputStream(System.out));
						globalMap.put("tLogRow_CONSOLE",
								consoleOut_talendLogs_CONSOLE);
					}

					consoleOut_talendLogs_CONSOLE
							.println(strBuffer_talendLogs_CONSOLE.toString());
					consoleOut_talendLogs_CONSOLE.flush();
					nb_line_talendLogs_CONSOLE++;
					// ////

					// ////

					// /////////////////////

					tos_count_talendLogs_CONSOLE++;

					/**
					 * [talendLogs_CONSOLE main ] stop
					 */

					/**
					 * [talendLogs_LOGS end ] start
					 */

					currentComponent = "talendLogs_LOGS";

				}

				ok_Hash.put("talendLogs_LOGS", true);
				end_Hash.put("talendLogs_LOGS", System.currentTimeMillis());

				/**
				 * [talendLogs_LOGS end ] stop
				 */

				/**
				 * [talendLogs_CONSOLE end ] start
				 */

				currentComponent = "talendLogs_CONSOLE";

				// ////
				// ////
				globalMap.put("talendLogs_CONSOLE_NB_LINE",
						nb_line_talendLogs_CONSOLE);

				// /////////////////////

				ok_Hash.put("talendLogs_CONSOLE", true);
				end_Hash.put("talendLogs_CONSOLE", System.currentTimeMillis());

				/**
				 * [talendLogs_CONSOLE end ] stop
				 */

				globalResumeTicket = true;

			}// end the resume

		} catch (Exception e) {

			throw new TalendException(e, currentComponent, globalMap);

		}

		globalMap.put("talendLogs_LOGS_SUBPROCESS_STATE", 1);
	}

	public String resuming_logs_dir_path = null;
	public String resuming_checkpoint_path = null;
	public String parent_part_launcher = null;
	private String resumeEntryMethodName = null;
	private boolean globalResumeTicket = false;

	public boolean watch = false;
	public int portStats = 3334;
	public int portTraces = 4334;
	public String clientHost;
	public String defaultClientHost = "localhost";
	public String contextStr = "Default";
	public String pid = "0";
	public String rootPid = null;
	public String fatherPid = null;
	public long startTime = 0;
	public boolean isChildJob = false;

	private ThreadLocal threadLocal = new ThreadLocal();
	{
		java.util.Map threadRunResultMap = new java.util.HashMap();
		threadRunResultMap.put("errorCode", null);
		threadRunResultMap.put("status", "");
		threadLocal.set(threadRunResultMap);
	}

	private java.util.Properties context_param = new java.util.Properties();

	public String status = "";

	public static void main(String[] args) {
		final fileExists fileExistsClass = new fileExists();

		int exitCode = fileExistsClass.runJobInTOS(args);

		System.exit(exitCode);
	}

	public String[][] runJob(String[] args) {

		int exitCode = runJobInTOS(args);
		String[][] bufferValue = new String[][] { { Integer.toString(exitCode) } };

		return bufferValue;
	}

	public int runJobInTOS(String[] args) {

		String lastStr = "";
		for (String arg : args) {
			if (arg.equalsIgnoreCase("--context_param")) {
				lastStr = arg;
			} else if (lastStr.equals("")) {
				evalParam(arg);
			} else {
				evalParam(lastStr + " " + arg);
				lastStr = "";
			}
		}

		if (clientHost == null) {
			clientHost = defaultClientHost;
		}

		if (pid == null || "0".equals(pid)) {
			pid = TalendString.getAsciiRandomString(6);
		}

		if (rootPid == null) {
			rootPid = pid;
		}
		if (fatherPid == null) {
			fatherPid = pid;
		} else {
			isChildJob = true;
		}

		// Resume: init the resumeUtil
		resumeEntryMethodName = ResumeUtil
				.getResumeEntryMethodName(resuming_checkpoint_path);
		resumeUtil = new ResumeUtil(resuming_logs_dir_path, isChildJob, rootPid);
		resumeUtil.initCommonInfo(pid, rootPid, fatherPid, projectName,
				jobName, contextStr, jobVersion);

		// Resume: jobStart
		resumeUtil.addLog("JOB_STARTED", "JOB:" + jobName,
				parent_part_launcher, Thread.currentThread().getId() + "", "",
				"", "", "");

		try {
			java.io.InputStream inContext = fileExists.class
					.getClassLoader()
					.getResourceAsStream(
							"drebretagne_geobretagne/fileexists_0_1/contexts/Default.properties");
			if (inContext != null) {
				defaultProps.load(inContext);
				inContext.close();
				context = new ContextProperties(defaultProps);
			}

			if (contextStr.compareTo("Default") != 0) {
				inContext = fileExists.class.getClassLoader()
						.getResourceAsStream(
								"drebretagne_geobretagne/fileexists_0_1/contexts/"
										+ contextStr + ".properties");
				if (inContext != null) {
					context.load(inContext);
					inContext.close();
				}
			}

			if (!context_param.isEmpty()) {
				context.putAll(context_param);
			}

			context.fileName = (String) context.getProperty("fileName");

			context.edigeoDir = (String) context.getProperty("edigeoDir");

			context.exportDir = (String) context.getProperty("exportDir");

			try {
				context.force = Boolean.parseBoolean(context
						.getProperty("force"));
			} catch (NumberFormatException e) {
				context.force = null;
			}

			context.tmpDir = (String) context.getProperty("tmpDir");

		} catch (java.io.IOException ie) {
			System.err.println("Could not load context " + contextStr);
			ie.printStackTrace();
		}

		long startUsedMemory = Runtime.getRuntime().totalMemory()
				- Runtime.getRuntime().freeMemory();
		long endUsedMemory = 0;
		long end = 0;

		startTime = System.currentTimeMillis();

		this.globalResumeTicket = true;// to run tPreJob

		this.globalResumeTicket = false;// to run others jobs

		try {
			errorCode = null;
			tForeach_1Process(globalMap);
			status = "end";
		} catch (TalendException e_tForeach_1) {
			status = "failure";
			e_tForeach_1.printStackTrace();
			globalMap.put("tForeach_1_SUBPROCESS_STATE", -1);

		} finally {
		}

		this.globalResumeTicket = true;// to run tPostJob

		end = System.currentTimeMillis();

		if (watch) {
			System.out.println((end - startTime) + " milliseconds");
		}

		endUsedMemory = Runtime.getRuntime().totalMemory()
				- Runtime.getRuntime().freeMemory();
		if (false) {
			System.out.println((endUsedMemory - startUsedMemory)
					+ " bytes memory increase when running : fileExists");
		}

		resumeUtil.addLog("JOB_ENDED", "JOB:" + jobName, parent_part_launcher,
				Thread.currentThread().getId() + "", "", "", "", "");

		if (errorCode == null) {
			return status != null && status.equals("failure") ? 1 : 0;
		} else {
			return errorCode.intValue();
		}
	}

	private void evalParam(String arg) {
		if (arg.startsWith("--resuming_logs_dir_path")) {
			resuming_logs_dir_path = arg.substring(25);
		} else if (arg.startsWith("--resuming_checkpoint_path")) {
			resuming_checkpoint_path = arg.substring(27);
		} else if (arg.startsWith("--parent_part_launcher")) {
			parent_part_launcher = arg.substring(23);
		} else if (arg.startsWith("--watch")) {
			watch = true;
		} else if (arg.startsWith("--stat_port=")) {
			portStats = Integer.parseInt(arg.substring(12));
		} else if (arg.startsWith("--trace_port=")) {
			portTraces = Integer.parseInt(arg.substring(13));
		} else if (arg.startsWith("--client_host=")) {
			clientHost = arg.substring(14);
		} else if (arg.startsWith("--context=")) {
			contextStr = arg.substring(10);
		} else if (arg.startsWith("--father_pid=")) {
			fatherPid = arg.substring(13);
		} else if (arg.startsWith("--root_pid=")) {
			rootPid = arg.substring(11);
		} else if (arg.startsWith("--pid=")) {
			pid = arg.substring(6);
		} else if (arg.startsWith("--context_param")) {
			String keyValue = arg.substring(16);
			int index = -1;
			if (keyValue != null && (index = keyValue.indexOf('=')) > -1) {
				context_param.put(keyValue.substring(0, index), keyValue
						.substring(index + 1));
			}
		}

	}

	public Integer getErrorCode() {
		return errorCode;
	}

	public String getStatus() {
		return status;
	}

	ResumeUtil resumeUtil = null;
}
/************************************************************************************************
 * 55389 characters generated by Spatial Data Integrator Powered by Talend on
 * the January 26, 2010 5:28:47 PM CET
 ************************************************************************************************/
